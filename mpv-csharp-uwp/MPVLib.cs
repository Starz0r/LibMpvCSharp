// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace MPVLib
{
    internal class SuppressUnmanagedCodeSecurityAttribute : Attribute
    {
    }

    /// <summary>
    /// <para>List of error codes than can be returned by API functions. 0 and positive</para>
    /// <para>return values always mean success, negative values are always errors.</para>
    /// </summary>
    public enum MpvError
    {
        /// <summary>
        /// <para>No error happened (used to signal successful operation).</para>
        /// <para>Keep in mind that many API functions returning error codes can also</para>
        /// <para>return positive values, which also indicate success. API users can</para>
        /// <para>hardcode the fact that &quot;&gt;= 0&quot; means success.</para>
        /// </summary>
        MPV_ERROR_SUCCESS = 0,
        /// <summary>
        /// <para>The event ringbuffer is full. This means the client is choked, and can't</para>
        /// <para>receive any events. This can happen when too many asynchronous requests</para>
        /// <para>have been made, but not answered. Probably never happens in practice,</para>
        /// <para>unless the mpv core is frozen for some reason, and the client keeps</para>
        /// <para>making asynchronous requests. (Bugs in the client API implementation</para>
        /// <para>could also trigger this, e.g. if events become &quot;lost&quot;.)</para>
        /// </summary>
        MPV_ERROR_EVENT_QUEUE_FULL = -1,
        /// <summary>Memory allocation failed.</summary>
        MPV_ERROR_NOMEM = -2,
        /// <summary>
        /// <para>The mpv core wasn't configured and initialized yet. See the notes in</para>
        /// <para>mpv_create().</para>
        /// </summary>
        MPV_ERROR_UNINITIALIZED = -3,
        /// <summary>
        /// <para>Generic catch-all error if a parameter is set to an invalid or</para>
        /// <para>unsupported value. This is used if there is no better error code.</para>
        /// </summary>
        MPV_ERROR_INVALID_PARAMETER = -4,
        /// <summary>Trying to set an option that doesn't exist.</summary>
        MPV_ERROR_OPTION_NOT_FOUND = -5,
        /// <summary>Trying to set an option using an unsupported MPV_FORMAT.</summary>
        MPV_ERROR_OPTION_FORMAT = -6,
        /// <summary>
        /// <para>Setting the option failed. Typically this happens if the provided option</para>
        /// <para>value could not be parsed.</para>
        /// </summary>
        MPV_ERROR_OPTION_ERROR = -7,
        /// <summary>The accessed property doesn't exist.</summary>
        MPV_ERROR_PROPERTY_NOT_FOUND = -8,
        /// <summary>Trying to set or get a property using an unsupported MPV_FORMAT.</summary>
        MPV_ERROR_PROPERTY_FORMAT = -9,
        /// <summary>
        /// <para>The property exists, but is not available. This usually happens when the</para>
        /// <para>associated subsystem is not active, e.g. querying audio parameters while</para>
        /// <para>audio is disabled.</para>
        /// </summary>
        MPV_ERROR_PROPERTY_UNAVAILABLE = -10,
        /// <summary>Error setting or getting a property.</summary>
        MPV_ERROR_PROPERTY_ERROR = -11,
        /// <summary>General error when running a command with mpv_command and similar.</summary>
        MPV_ERROR_COMMAND = -12,
        /// <summary>Generic error on loading (usually used with mpv_event_end_file.error).</summary>
        MPV_ERROR_LOADING_FAILED = -13,
        /// <summary>Initializing the audio output failed.</summary>
        MPV_ERROR_AO_INIT_FAILED = -14,
        /// <summary>Initializing the video output failed.</summary>
        MPV_ERROR_VO_INIT_FAILED = -15,
        /// <summary>
        /// <para>There was no audio or video data to play. This also happens if the</para>
        /// <para>file was recognized, but did not contain any audio or video streams,</para>
        /// <para>or no streams were selected.</para>
        /// </summary>
        MPV_ERROR_NOTHING_TO_PLAY = -16,
        /// <summary>
        /// <para>When trying to load the file, the file format could not be determined,</para>
        /// <para>or the file was too broken to open it.</para>
        /// </summary>
        MPV_ERROR_UNKNOWN_FORMAT = -17,
        /// <summary>
        /// <para>Generic error for signaling that certain system requirements are not</para>
        /// <para>fulfilled.</para>
        /// </summary>
        MPV_ERROR_UNSUPPORTED = -18,
        /// <summary>The API function which was called is a stub only.</summary>
        MPV_ERROR_NOT_IMPLEMENTED = -19,
        /// <summary>Unspecified error.</summary>
        MPV_ERROR_GENERIC = -20
    }

    /// <summary>
    /// <para>Data format for options and properties. The API functions to get/set</para>
    /// <para>properties and options support multiple formats, and this enum describes</para>
    /// <para>them.</para>
    /// </summary>
    public enum MpvFormat : uint
    {
        /// <summary>Invalid. Sometimes used for empty values.</summary>
        MPV_FORMAT_NONE = 0,
        /// <summary>
        /// <para>The basic type is char*. It returns the raw property string, like</para>
        /// <para>using ${=property} in input.conf (see input.rst).</para>
        /// </summary>
        /// <remarks>
        /// <para>NULL isn't an allowed value.</para>
        /// <para>Warning: although the encoding is usually UTF-8, this is not always the</para>
        /// <para>case. File tags often store strings in some legacy codepage,</para>
        /// <para>and even filenames don't necessarily have to be in UTF-8 (at</para>
        /// <para>least on Linux). If you pass the strings to code that requires</para>
        /// <para>valid UTF-8, you have to sanitize it in some way.</para>
        /// <para>On Windows, filenames are always UTF-8, and libmpv converts</para>
        /// <para>between UTF-8 and UTF-16 when using win32 API functions. See</para>
        /// <para>the &quot;Encoding of filenames&quot; section for details.</para>
        /// <para>Example for reading:</para>
        /// <para>char *result = NULL;</para>
        /// <para>if (mpv_get_property(ctx, &quot;property&quot;, MPV_FORMAT_STRING,&amp;result)&lt;&gt;0)</para>
        /// <para>goto error;</para>
        /// <para>printf(&quot;%sresult);</para>
        /// <para>mpv_free(result);</para>
        /// <para>Or just use mpv_get_property_string().</para>
        /// <para>Example for writing:</para>
        /// <para>char *value = &quot;the new value&quot;;</para>
        /// <para>// yep, you pass the address to the variable</para>
        /// <para>// (needed for symmetry with other types and mpv_get_property)</para>
        /// <para>mpv_set_property(ctx, &quot;property&quot;, MPV_FORMAT_STRING,&amp;value);</para>
        /// <para>Or just use mpv_set_property_string().</para>
        /// </remarks>
        MPV_FORMAT_STRING = 1,
        /// <summary>
        /// <para>The basic type is char*. It returns the OSD property string, like</para>
        /// <para>using ${property} in input.conf (see input.rst). In many cases, this</para>
        /// <para>is the same as the raw string, but in other cases it's formatted for</para>
        /// <para>display on OSD. It's intended to be human readable. Do not attempt to</para>
        /// <para>parse these strings.</para>
        /// </summary>
        /// <remarks>Only valid when doing read access. The rest works like MPV_FORMAT_STRING.</remarks>
        MPV_FORMAT_OSD_STRING = 2,
        /// <summary>
        /// <para>The basic type is int. The only allowed values are 0 (&quot;no&quot;)</para>
        /// <para>and 1 (&quot;yes&quot;).</para>
        /// </summary>
        /// <remarks>
        /// <para>Example for reading:</para>
        /// <para>int result;</para>
        /// <para>if (mpv_get_property(ctx, &quot;property&quot;, MPV_FORMAT_FLAG,&amp;result)&lt;&gt;0)</para>
        /// <para>goto error;</para>
        /// <para>printf(&quot;%sresult ? &quot;true&quot; : &quot;false&quot;);</para>
        /// <para>Example for writing:</para>
        /// <para>int flag = 1;</para>
        /// <para>mpv_set_property(ctx, &quot;property&quot;, MPV_FORMAT_FLAG,&amp;flag);</para>
        /// </remarks>
        MPV_FORMAT_FLAG = 3,
        /// <summary>The basic type is int64_t.</summary>
        MPV_FORMAT_INT64 = 4,
        /// <summary>The basic type is double.</summary>
        MPV_FORMAT_DOUBLE = 5,
        /// <summary>The type is mpv_node.</summary>
        /// <remarks>
        /// <para>For reading, you usually would pass a pointer to a stack-allocated</para>
        /// <para>mpv_node value to mpv, and when you're done you call</para>
        /// <para>mpv_free_node_contents(&amp;node).</para>
        /// <para>You're expected not to write to the data - if you have to, copy it</para>
        /// <para>first (which you have to do manually).</para>
        /// <para>For writing, you construct your own mpv_node, and pass a pointer to the</para>
        /// <para>API. The API will never write to your data (and copy it if needed), so</para>
        /// <para>you're free to use any form of allocation or memory management you like.</para>
        /// <para>Warning: when reading, always check the mpv_node.format member. For</para>
        /// <para>example, properties might change their type in future versions</para>
        /// <para>of mpv, or sometimes even during runtime.</para>
        /// <para>Example for reading:</para>
        /// <para>mpv_node result;</para>
        /// <para>if (mpv_get_property(ctx, &quot;property&quot;, MPV_FORMAT_NODE,&amp;result)&lt;&gt;0)</para>
        /// <para>goto error;</para>
        /// <para>printf(&quot;format=%d(int)result.format);</para>
        /// <para>mpv_free_node_contents(&amp;result).</para>
        /// <para>Example for writing:</para>
        /// <para>mpv_node value;</para>
        /// <para>value.format = MPV_FORMAT_STRING;</para>
        /// <para>value.u.string = &quot;hello&quot;;</para>
        /// <para>mpv_set_property(ctx, &quot;property&quot;, MPV_FORMAT_NODE,&amp;value);</para>
        /// </remarks>
        MPV_FORMAT_NODE = 6,
        /// <summary>Used with mpv_node only. Can usually not be used directly.</summary>
        MPV_FORMAT_NODE_ARRAY = 7,
        /// <summary>See MPV_FORMAT_NODE_ARRAY.</summary>
        MPV_FORMAT_NODE_MAP = 8,
        /// <summary>
        /// <para>A raw, untyped byte array. Only used only with mpv_node, and only in</para>
        /// <para>some very special situations. (Currently, only for the screenshot-raw</para>
        /// <para>command.)</para>
        /// </summary>
        MPV_FORMAT_BYTE_ARRAY = 9
    }

    public enum MpvEventId : uint
    {
        /// <summary>Nothing happened. Happens on timeouts or sporadic wakeups.</summary>
        MPV_EVENT_NONE = 0,
        /// <summary>
        /// <para>Happens when the player quits. The player enters a state where it tries</para>
        /// <para>to disconnect all clients. Most requests to the player will fail, and</para>
        /// <para>mpv_wait_event() will always return instantly (returning new shutdown</para>
        /// <para>events if no other events are queued). The client should react to this</para>
        /// <para>and quit with mpv_detach_destroy() as soon as possible.</para>
        /// </summary>
        MPV_EVENT_SHUTDOWN = 1,
        /// <summary>See mpv_request_log_messages().</summary>
        MPV_EVENT_LOG_MESSAGE = 2,
        /// <summary>
        /// <para>Reply to a mpv_get_property_async() request.</para>
        /// <para>See also mpv_event and mpv_event_property.</para>
        /// </summary>
        MPV_EVENT_GET_PROPERTY_REPLY = 3,
        /// <summary>
        /// <para>Reply to a mpv_set_property_async() request.</para>
        /// <para>(Unlike MPV_EVENT_GET_PROPERTY, mpv_event_property is not used.)</para>
        /// </summary>
        MPV_EVENT_SET_PROPERTY_REPLY = 4,
        /// <summary>Reply to a mpv_command_async() request.</summary>
        MPV_EVENT_COMMAND_REPLY = 5,
        /// <summary>Notification before playback start of a file (before the file is loaded).</summary>
        MPV_EVENT_START_FILE = 6,
        /// <summary>
        /// <para>Notification after playback end (after the file was unloaded).</para>
        /// <para>See also mpv_event and mpv_event_end_file.</para>
        /// </summary>
        MPV_EVENT_END_FILE = 7,
        /// <summary>
        /// <para>Notification when the file has been loaded (headers were read etc.), and</para>
        /// <para>decoding starts.</para>
        /// </summary>
        MPV_EVENT_FILE_LOADED = 8,
        /// <summary>
        /// <para>The list of video/audio/subtitle tracks was changed. (E.g. a new track</para>
        /// <para>was found. This doesn't necessarily indicate a track switch; for this,</para>
        /// <para>MPV_EVENT_TRACK_SWITCHED is used.)</para>
        /// </summary>
        /// <remarks>
        /// <para>This is equivalent to using mpv_observe_property() on the</para>
        /// <para>&quot;track-list&quot; property. The event is redundant, and might</para>
        /// <para>be removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_TRACKS_CHANGED = 9,
        /// <summary>A video/audio/subtitle track was switched on or off.</summary>
        /// <remarks>
        /// <para>This is equivalent to using mpv_observe_property() on the</para>
        /// <para>&quot;vid&quot;, &quot;aid&quot;, and &quot;sid&quot; properties. The event is redundant,</para>
        /// <para>and might be removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_TRACK_SWITCHED = 10,
        /// <summary>
        /// <para>Idle mode was entered. In this mode, no file is played, and the playback</para>
        /// <para>core waits for new commands. (The command line player normally quits</para>
        /// <para>instead of entering idle mode, unless --idle was specified. If mpv</para>
        /// <para>was started with mpv_create(), idle mode is enabled by default.)</para>
        /// </summary>
        MPV_EVENT_IDLE = 11,
        /// <summary>Playback was paused. This indicates the user pause state.</summary>
        /// <remarks>
        /// <para>The user pause state is the state the user requested (changed with the</para>
        /// <para>&quot;pause&quot; property). There is an internal pause state too, which is entered</para>
        /// <para>if e.g. the network is too slow (the &quot;core-idle&quot; property generally</para>
        /// <para>indicates whether the core is playing or waiting).</para>
        /// <para>This event is sent whenever any pause states change, not only the user</para>
        /// <para>state. You might get multiple events in a row while these states change</para>
        /// <para>independently. But the event ID sent always indicates the user pause</para>
        /// <para>state.</para>
        /// <para>If you don't want to deal with this, use mpv_observe_property() on the</para>
        /// <para>&quot;pause&quot; property and ignore MPV_EVENT_PAUSE/UNPAUSE. Likewise, the</para>
        /// <para>&quot;core-idle&quot; property tells you whether video is actually playing or not.</para>
        /// <para>The event is redundant with mpv_observe_property() as</para>
        /// <para>mentioned above, and might be removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_PAUSE = 12,
        /// <summary>Playback was unpaused. See MPV_EVENT_PAUSE for not so obvious details.</summary>
        /// <remarks>
        /// <para>The event is redundant with mpv_observe_property() as</para>
        /// <para>explained in the MPV_EVENT_PAUSE comments, and might be</para>
        /// <para>removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_UNPAUSE = 13,
        /// <summary>
        /// <para>Sent every time after a video frame is displayed. Note that currently,</para>
        /// <para>this will be sent in lower frequency if there is no video, or playback</para>
        /// <para>is paused - but that will be removed in the future, and it will be</para>
        /// <para>restricted to video frames only.</para>
        /// </summary>
        MPV_EVENT_TICK = 14,
        /// <remarks>
        /// <para>This was used internally with the internal &quot;script_dispatch&quot;</para>
        /// <para>command to dispatch keyboard and mouse input for the OSC.</para>
        /// <para>It was never useful in general and has been completely</para>
        /// <para>replaced with &quot;script-binding&quot;.</para>
        /// <para>This event never happens anymore, and is included in this</para>
        /// <para>header only for compatibility.</para>
        /// </remarks>
        MPV_EVENT_SCRIPT_INPUT_DISPATCH = 15,
        /// <summary>
        /// <para>Triggered by the script-message input command. The command uses the</para>
        /// <para>first argument of the command as client name (see mpv_client_name()) to</para>
        /// <para>dispatch the message, and passes along all arguments starting from the</para>
        /// <para>second argument as strings.</para>
        /// <para>See also mpv_event and mpv_event_client_message.</para>
        /// </summary>
        MPV_EVENT_CLIENT_MESSAGE = 16,
        /// <summary>
        /// <para>Happens after video changed in some way. This can happen on resolution</para>
        /// <para>changes, pixel format changes, or video filter changes. The event is</para>
        /// <para>sent after the video filters and the VO are reconfigured. Applications</para>
        /// <para>embedding a mpv window should listen to this event in order to resize</para>
        /// <para>the window if needed.</para>
        /// <para>Note that this event can happen sporadically, and you should check</para>
        /// <para>yourself whether the video parameters really changed before doing</para>
        /// <para>something expensive.</para>
        /// </summary>
        MPV_EVENT_VIDEO_RECONFIG = 17,
        /// <summary>
        /// <para>Similar to MPV_EVENT_VIDEO_RECONFIG. This is relatively uninteresting,</para>
        /// <para>because there is no such thing as audio output embedding.</para>
        /// </summary>
        MPV_EVENT_AUDIO_RECONFIG = 18,
        /// <summary>
        /// <para>Happens when metadata (like file tags) is possibly updated. (It's left</para>
        /// <para>unspecified whether this happens on file start or only when it changes</para>
        /// <para>within a file.)</para>
        /// </summary>
        /// <remarks>
        /// <para>This is equivalent to using mpv_observe_property() on the</para>
        /// <para>&quot;metadata&quot; property. The event is redundant, and might</para>
        /// <para>be removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_METADATA_UPDATE = 19,
        /// <summary>
        /// <para>Happens when a seek was initiated. Playback stops. Usually it will</para>
        /// <para>resume with MPV_EVENT_PLAYBACK_RESTART as soon as the seek is finished.</para>
        /// </summary>
        MPV_EVENT_SEEK = 20,
        /// <summary>
        /// <para>There was a discontinuity of some sort (like a seek), and playback</para>
        /// <para>was reinitialized. Usually happens after seeking, or ordered chapter</para>
        /// <para>segment switches. The main purpose is allowing the client to detect</para>
        /// <para>when a seek request is finished.</para>
        /// </summary>
        MPV_EVENT_PLAYBACK_RESTART = 21,
        /// <summary>
        /// <para>Event sent due to mpv_observe_property().</para>
        /// <para>See also mpv_event and mpv_event_property.</para>
        /// </summary>
        MPV_EVENT_PROPERTY_CHANGE = 22,
        /// <summary>Happens when the current chapter changes.</summary>
        /// <remarks>
        /// <para>This is equivalent to using mpv_observe_property() on the</para>
        /// <para>&quot;chapter&quot; property. The event is redundant, and might</para>
        /// <para>be removed in the far future.</para>
        /// </remarks>
        MPV_EVENT_CHAPTER_CHANGE = 23,
        /// <summary>
        /// <para>Happens if the internal per-mpv_handle ringbuffer overflows, and at</para>
        /// <para>least 1 event had to be dropped. This can happen if the client doesn't</para>
        /// <para>read the event queue quickly enough with mpv_wait_event(), or if the</para>
        /// <para>client makes a very large number of asynchronous calls at once.</para>
        /// </summary>
        /// <remarks>
        /// <para>Event delivery will continue normally once this event was returned</para>
        /// <para>(this forces the client to empty the queue completely).</para>
        /// </remarks>
        MPV_EVENT_QUEUE_OVERFLOW = 24
    }

    /// <summary>
    /// <para>Numeric log levels. The lower the number, the more important the message is.</para>
    /// <para>MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in</para>
    /// <para>the comment after the value is the name of the log level as used for the</para>
    /// <para>mpv_request_log_messages() function.</para>
    /// <para>Unused numeric values are unused, but reserved for future use.</para>
    /// </summary>
    public enum MpvLogLevel : uint
    {
        MPV_LOG_LEVEL_NONE = 0,
        /// <summary>&quot;no&quot;    - disable absolutely all messages</summary>
        MPV_LOG_LEVEL_FATAL = 10,
        /// <summary>&quot;fatal&quot; - critical/aborting errors</summary>
        MPV_LOG_LEVEL_ERROR = 20,
        /// <summary>&quot;error&quot; - simple errors</summary>
        MPV_LOG_LEVEL_WARN = 30,
        /// <summary>&quot;warn&quot;  - possible problems</summary>
        MPV_LOG_LEVEL_INFO = 40,
        /// <summary>&quot;info&quot;  - informational message</summary>
        MPV_LOG_LEVEL_V = 50,
        /// <summary>&quot;v&quot;     - noisy informational message</summary>
        MPV_LOG_LEVEL_DEBUG = 60,
        /// <summary>&quot;debug&quot; - very noisy technical information</summary>
        MPV_LOG_LEVEL_TRACE = 70
    }

    /// <summary>Since API version 1.9.</summary>
    public enum MpvEndFileReason : uint
    {
        /// <summary>
        /// <para>The end of file was reached. Sometimes this may also happen on</para>
        /// <para>incomplete or corrupted files, or if the network connection was</para>
        /// <para>interrupted when playing a remote file. It also happens if the</para>
        /// <para>playback range was restricted with --end or --frames or similar.</para>
        /// </summary>
        MPV_END_FILE_REASON_EOF = 0,
        /// <summary>Playback was stopped by an external action (e.g. playlist controls).</summary>
        MPV_END_FILE_REASON_STOP = 2,
        /// <summary>Playback was stopped by the quit command or player shutdown.</summary>
        MPV_END_FILE_REASON_QUIT = 3,
        /// <summary>
        /// <para>Some kind of error happened that lead to playback abort. Does not</para>
        /// <para>necessarily happen on incomplete or broken files (in these cases, both</para>
        /// <para>MPV_END_FILE_REASON_ERROR or MPV_END_FILE_REASON_EOF are possible).</para>
        /// </summary>
        /// <remarks>mpv_event_end_file.error will be set.</remarks>
        MPV_END_FILE_REASON_ERROR = 4,
        /// <summary>
        /// <para>The file was a playlist or similar. When the playlist is read, its</para>
        /// <para>entries will be appended to the playlist after the entry of the current</para>
        /// <para>file, the entry of the current file is removed, and a MPV_EVENT_END_FILE</para>
        /// <para>event is sent with reason set to MPV_END_FILE_REASON_REDIRECT. Then</para>
        /// <para>playback continues with the playlist contents.</para>
        /// <para>Since API version 1.18.</para>
        /// </summary>
        MPV_END_FILE_REASON_REDIRECT = 5
    }

    public enum MpvSubApi : uint
    {
        /// <summary>
        /// <para>For using mpv's OpenGL renderer on an external OpenGL context.</para>
        /// <para>mpv_get_sub_api(MPV_SUB_API_OPENGL_CB) returns mpv_opengl_cb_context*.</para>
        /// <para>This context can be used with mpv_opengl_cb_* functions.</para>
        /// <para>Will return NULL if unavailable (if OpenGL support was not compiled in).</para>
        /// <para>See opengl_cb.h for details.</para>
        /// </summary>
        MPV_SUB_API_OPENGL_CB = 1
    }

    /// <summary>
    /// <para>Client context used by the client API. Every client has its own private</para>
    /// <para>handle.</para>
    /// </summary>
    public unsafe partial class MpvHandle
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvHandle>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvHandle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvHandle(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvHandle __CreateInstance(global::MPVLib.MpvHandle.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvHandle(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvHandle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvHandle.__Internal));
            *(global::MPVLib.MpvHandle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvHandle(global::MPVLib.MpvHandle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvHandle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Generic data storage.</summary>
    /// <remarks>
    /// <para>If mpv writes this struct (e.g. via mpv_get_property()), you must not change</para>
    /// <para>the data. In some cases (mpv_get_property()), you have to free it with</para>
    /// <para>mpv_free_node_contents(). If you fill this struct yourself, you're also</para>
    /// <para>responsible for freeing it, and you must not call mpv_free_node_contents().</para>
    /// </remarks>
    public unsafe partial class MpvNode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::MPVLib.MpvNode._.__Internal u;

            [FieldOffset(8)]
            internal global::MPVLib.MpvFormat format;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN8mpv_nodeC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr @string;

                [FieldOffset(0)]
                internal int flag;

                [FieldOffset(0)]
                internal long int64;

                [FieldOffset(0)]
                internal double double_;

                [FieldOffset(0)]
                internal global::System.IntPtr list;

                [FieldOffset(0)]
                internal global::System.IntPtr ba;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvNode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvNode(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvNode __CreateInstance(global::MPVLib.MpvNode.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvNode(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvNode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNode.__Internal));
            *(global::MPVLib.MpvNode.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvNode(global::MPVLib.MpvNode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvNode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvNode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvNode(global::MPVLib.MpvNode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvNode.__Internal*) __Instance) = *((global::MPVLib.MpvNode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvNode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::MPVLib.MpvFormat Format
        {
            get
            {
                return ((global::MPVLib.MpvNode.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::MPVLib.MpvNode.__Internal*)__Instance)->format = value;
            }
        }
    }

    /// <summary>(see mpv_node)</summary>
    public unsafe partial class MpvNodeList : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int num;

            [FieldOffset(8)]
            internal global::System.IntPtr values;

            [FieldOffset(16)]
            internal global::System.IntPtr keys;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN13mpv_node_listC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvNodeList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvNodeList>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvNodeList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvNodeList(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvNodeList __CreateInstance(global::MPVLib.MpvNodeList.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvNodeList(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvNodeList.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNodeList.__Internal));
            *(global::MPVLib.MpvNodeList.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvNodeList(global::MPVLib.MpvNodeList.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvNodeList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvNodeList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNodeList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvNodeList(global::MPVLib.MpvNodeList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvNodeList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvNodeList.__Internal*) __Instance) = *((global::MPVLib.MpvNodeList.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvNodeList __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Num
        {
            get
            {
                return ((global::MPVLib.MpvNodeList.__Internal*) __Instance)->num;
            }

            set
            {
                ((global::MPVLib.MpvNodeList.__Internal*)__Instance)->num = value;
            }
        }

        public global::MPVLib.MpvNode Values
        {
            get
            {
                global::MPVLib.MpvNode __result0;
                if (((global::MPVLib.MpvNodeList.__Internal*) __Instance)->values == IntPtr.Zero) __result0 = null;
                else if (global::MPVLib.MpvNode.NativeToManagedMap.ContainsKey(((global::MPVLib.MpvNodeList.__Internal*) __Instance)->values))
                    __result0 = (global::MPVLib.MpvNode) global::MPVLib.MpvNode.NativeToManagedMap[((global::MPVLib.MpvNodeList.__Internal*) __Instance)->values];
                else __result0 = global::MPVLib.MpvNode.__CreateInstance(((global::MPVLib.MpvNodeList.__Internal*) __Instance)->values);
                return __result0;
            }

            set
            {
                ((global::MPVLib.MpvNodeList.__Internal*)__Instance)->values = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte** Keys
        {
            get
            {
                return (sbyte**) ((global::MPVLib.MpvNodeList.__Internal*) __Instance)->keys;
            }

            set
            {
                ((global::MPVLib.MpvNodeList.__Internal*)__Instance)->keys = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>(see mpv_node)</summary>
    public unsafe partial class MpvByteArray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal ulong size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN14mpv_byte_arrayC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvByteArray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvByteArray>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvByteArray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvByteArray(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvByteArray __CreateInstance(global::MPVLib.MpvByteArray.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvByteArray(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvByteArray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvByteArray.__Internal));
            *(global::MPVLib.MpvByteArray.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvByteArray(global::MPVLib.MpvByteArray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvByteArray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvByteArray()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvByteArray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvByteArray(global::MPVLib.MpvByteArray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvByteArray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvByteArray.__Internal*) __Instance) = *((global::MPVLib.MpvByteArray.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvByteArray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::MPVLib.MpvByteArray.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::MPVLib.MpvByteArray.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public ulong Size
        {
            get
            {
                return ((global::MPVLib.MpvByteArray.__Internal*) __Instance)->size;
            }

            set
            {
                ((global::MPVLib.MpvByteArray.__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class MpvEventProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr name;

            [FieldOffset(8)]
            internal global::MPVLib.MpvFormat format;

            [FieldOffset(16)]
            internal global::System.IntPtr data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN18mpv_event_propertyC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEventProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventProperty(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEventProperty __CreateInstance(global::MPVLib.MpvEventProperty.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventProperty(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEventProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventProperty.__Internal));
            *(global::MPVLib.MpvEventProperty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEventProperty(global::MPVLib.MpvEventProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEventProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEventProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEventProperty(global::MPVLib.MpvEventProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEventProperty.__Internal*) __Instance) = *((global::MPVLib.MpvEventProperty.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEventProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::MPVLib.MpvEventProperty.__Internal*) __Instance)->name);
            }

            set
            {
                ((global::MPVLib.MpvEventProperty.__Internal*)__Instance)->name = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public global::MPVLib.MpvFormat Format
        {
            get
            {
                return ((global::MPVLib.MpvEventProperty.__Internal*) __Instance)->format;
            }

            set
            {
                ((global::MPVLib.MpvEventProperty.__Internal*)__Instance)->format = value;
            }
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::MPVLib.MpvEventProperty.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::MPVLib.MpvEventProperty.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class MpvEventLogMessage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr prefix;

            [FieldOffset(8)]
            internal global::System.IntPtr level;

            [FieldOffset(16)]
            internal global::System.IntPtr text;

            [FieldOffset(24)]
            internal global::MPVLib.MpvLogLevel log_level;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN21mpv_event_log_messageC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventLogMessage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventLogMessage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEventLogMessage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventLogMessage(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEventLogMessage __CreateInstance(global::MPVLib.MpvEventLogMessage.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventLogMessage(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEventLogMessage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventLogMessage.__Internal));
            *(global::MPVLib.MpvEventLogMessage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEventLogMessage(global::MPVLib.MpvEventLogMessage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEventLogMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEventLogMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventLogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEventLogMessage(global::MPVLib.MpvEventLogMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventLogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEventLogMessage.__Internal*) __Instance) = *((global::MPVLib.MpvEventLogMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEventLogMessage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Prefix
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::MPVLib.MpvEventLogMessage.__Internal*) __Instance)->prefix);
            }

            set
            {
                ((global::MPVLib.MpvEventLogMessage.__Internal*)__Instance)->prefix = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string Level
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::MPVLib.MpvEventLogMessage.__Internal*) __Instance)->level);
            }

            set
            {
                ((global::MPVLib.MpvEventLogMessage.__Internal*)__Instance)->level = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string Text
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::MPVLib.MpvEventLogMessage.__Internal*) __Instance)->text);
            }

            set
            {
                ((global::MPVLib.MpvEventLogMessage.__Internal*)__Instance)->text = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public global::MPVLib.MpvLogLevel LogLevel
        {
            get
            {
                return ((global::MPVLib.MpvEventLogMessage.__Internal*) __Instance)->log_level;
            }

            set
            {
                ((global::MPVLib.MpvEventLogMessage.__Internal*)__Instance)->log_level = value;
            }
        }
    }

    public unsafe partial class MpvEventEndFile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int reason;

            [FieldOffset(4)]
            internal int error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN18mpv_event_end_fileC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventEndFile> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventEndFile>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEventEndFile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventEndFile(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEventEndFile __CreateInstance(global::MPVLib.MpvEventEndFile.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventEndFile(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEventEndFile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventEndFile.__Internal));
            *(global::MPVLib.MpvEventEndFile.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEventEndFile(global::MPVLib.MpvEventEndFile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEventEndFile(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEventEndFile()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventEndFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEventEndFile(global::MPVLib.MpvEventEndFile _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventEndFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEventEndFile.__Internal*) __Instance) = *((global::MPVLib.MpvEventEndFile.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEventEndFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Reason
        {
            get
            {
                return ((global::MPVLib.MpvEventEndFile.__Internal*) __Instance)->reason;
            }

            set
            {
                ((global::MPVLib.MpvEventEndFile.__Internal*)__Instance)->reason = value;
            }
        }

        public int Error
        {
            get
            {
                return ((global::MPVLib.MpvEventEndFile.__Internal*) __Instance)->error;
            }

            set
            {
                ((global::MPVLib.MpvEventEndFile.__Internal*)__Instance)->error = value;
            }
        }
    }

    /// <remarks>see MPV_EVENT_SCRIPT_INPUT_DISPATCH for remarks</remarks>
    public unsafe partial class MpvEventScriptInputDispatch : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int arg0;

            [FieldOffset(8)]
            internal global::System.IntPtr type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN31mpv_event_script_input_dispatchC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventScriptInputDispatch> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventScriptInputDispatch>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEventScriptInputDispatch __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventScriptInputDispatch(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEventScriptInputDispatch __CreateInstance(global::MPVLib.MpvEventScriptInputDispatch.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventScriptInputDispatch(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEventScriptInputDispatch.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventScriptInputDispatch.__Internal));
            *(global::MPVLib.MpvEventScriptInputDispatch.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEventScriptInputDispatch(global::MPVLib.MpvEventScriptInputDispatch.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEventScriptInputDispatch(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEventScriptInputDispatch()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventScriptInputDispatch.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEventScriptInputDispatch(global::MPVLib.MpvEventScriptInputDispatch _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventScriptInputDispatch.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEventScriptInputDispatch.__Internal*) __Instance) = *((global::MPVLib.MpvEventScriptInputDispatch.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEventScriptInputDispatch __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Arg0
        {
            get
            {
                return ((global::MPVLib.MpvEventScriptInputDispatch.__Internal*) __Instance)->arg0;
            }

            set
            {
                ((global::MPVLib.MpvEventScriptInputDispatch.__Internal*)__Instance)->arg0 = value;
            }
        }

        public string Type
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::MPVLib.MpvEventScriptInputDispatch.__Internal*) __Instance)->type);
            }

            set
            {
                ((global::MPVLib.MpvEventScriptInputDispatch.__Internal*)__Instance)->type = Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class MpvEventClientMessage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int num_args;

            [FieldOffset(8)]
            internal global::System.IntPtr args;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24mpv_event_client_messageC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventClientMessage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEventClientMessage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEventClientMessage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventClientMessage(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEventClientMessage __CreateInstance(global::MPVLib.MpvEventClientMessage.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEventClientMessage(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEventClientMessage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventClientMessage.__Internal));
            *(global::MPVLib.MpvEventClientMessage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEventClientMessage(global::MPVLib.MpvEventClientMessage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEventClientMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEventClientMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventClientMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEventClientMessage(global::MPVLib.MpvEventClientMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEventClientMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEventClientMessage.__Internal*) __Instance) = *((global::MPVLib.MpvEventClientMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEventClientMessage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int NumArgs
        {
            get
            {
                return ((global::MPVLib.MpvEventClientMessage.__Internal*) __Instance)->num_args;
            }

            set
            {
                ((global::MPVLib.MpvEventClientMessage.__Internal*)__Instance)->num_args = value;
            }
        }

        public sbyte** Args
        {
            get
            {
                return (sbyte**) ((global::MPVLib.MpvEventClientMessage.__Internal*) __Instance)->args;
            }

            set
            {
                ((global::MPVLib.MpvEventClientMessage.__Internal*)__Instance)->args = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class MpvEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::MPVLib.MpvEventId event_id;

            [FieldOffset(4)]
            internal int error;

            [FieldOffset(8)]
            internal ulong reply_userdata;

            [FieldOffset(16)]
            internal global::System.IntPtr data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9mpv_eventC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEvent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvEvent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvEvent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEvent(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvEvent __CreateInstance(global::MPVLib.MpvEvent.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvEvent(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvEvent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEvent.__Internal));
            *(global::MPVLib.MpvEvent.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvEvent(global::MPVLib.MpvEvent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvEvent(global::MPVLib.MpvEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvEvent.__Internal*) __Instance) = *((global::MPVLib.MpvEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::MPVLib.MpvEventId EventId
        {
            get
            {
                return ((global::MPVLib.MpvEvent.__Internal*) __Instance)->event_id;
            }

            set
            {
                ((global::MPVLib.MpvEvent.__Internal*)__Instance)->event_id = value;
            }
        }

        public int Error
        {
            get
            {
                return ((global::MPVLib.MpvEvent.__Internal*) __Instance)->error;
            }

            set
            {
                ((global::MPVLib.MpvEvent.__Internal*)__Instance)->error = value;
            }
        }

        public ulong ReplyUserdata
        {
            get
            {
                return ((global::MPVLib.MpvEvent.__Internal*) __Instance)->reply_userdata;
            }

            set
            {
                ((global::MPVLib.MpvEvent.__Internal*)__Instance)->reply_userdata = value;
            }
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::MPVLib.MpvEvent.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::MPVLib.MpvEvent.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class client
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_client_api_version")]
            internal static extern ulong MpvClientApiVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_error_string")]
            internal static extern global::System.IntPtr MpvErrorString(int error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_free")]
            internal static extern void MpvFree(global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_client_name")]
            internal static extern global::System.IntPtr MpvClientName(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_create")]
            internal static extern global::System.IntPtr MpvCreate();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_initialize")]
            internal static extern int MpvInitialize(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_detach_destroy")]
            internal static extern void MpvDetachDestroy(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_terminate_destroy")]
            internal static extern void MpvTerminateDestroy(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_create_client")]
            internal static extern global::System.IntPtr MpvCreateClient(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_load_config_file")]
            internal static extern int MpvLoadConfigFile(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_suspend")]
            internal static extern void MpvSuspend(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_resume")]
            internal static extern void MpvResume(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_time_us")]
            internal static extern long MpvGetTimeUs(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_free_node_contents")]
            internal static extern void MpvFreeNodeContents(global::System.IntPtr node);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_option")]
            internal static extern int MpvSetOption(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_option_string")]
            internal static extern int MpvSetOptionString(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_command")]
            internal static extern int MpvCommand(global::System.IntPtr ctx, sbyte** args);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_command_node")]
            internal static extern int MpvCommandNode(global::System.IntPtr ctx, global::System.IntPtr args, global::System.IntPtr result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_command_string")]
            internal static extern int MpvCommandString(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string args);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_command_async")]
            internal static extern int MpvCommandAsync(global::System.IntPtr ctx, ulong reply_userdata, sbyte** args);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_command_node_async")]
            internal static extern int MpvCommandNodeAsync(global::System.IntPtr ctx, ulong reply_userdata, global::System.IntPtr args);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_property")]
            internal static extern int MpvSetProperty(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_property_string")]
            internal static extern int MpvSetPropertyString(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_property_async")]
            internal static extern int MpvSetPropertyAsync(global::System.IntPtr ctx, ulong reply_userdata, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_property")]
            internal static extern int MpvGetProperty(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_property_string")]
            internal static extern sbyte* MpvGetPropertyString(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_property_osd_string")]
            internal static extern sbyte* MpvGetPropertyOsdString(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_property_async")]
            internal static extern int MpvGetPropertyAsync(global::System.IntPtr ctx, ulong reply_userdata, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_observe_property")]
            internal static extern int MpvObserveProperty(global::System.IntPtr mpv, ulong reply_userdata, [MarshalAs(UnmanagedType.LPStr)] string name, global::MPVLib.MpvFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_unobserve_property")]
            internal static extern int MpvUnobserveProperty(global::System.IntPtr mpv, ulong registered_reply_userdata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_event_name")]
            internal static extern global::System.IntPtr MpvEventName(global::MPVLib.MpvEventId @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_request_event")]
            internal static extern int MpvRequestEvent(global::System.IntPtr ctx, global::MPVLib.MpvEventId @event, int enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_request_log_messages")]
            internal static extern int MpvRequestLogMessages(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string min_level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_wait_event")]
            internal static extern global::System.IntPtr MpvWaitEvent(global::System.IntPtr ctx, double timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_wakeup")]
            internal static extern void MpvWakeup(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_set_wakeup_callback")]
            internal static extern void MpvSetWakeupCallback(global::System.IntPtr ctx, global::System.IntPtr cb, global::System.IntPtr d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_wakeup_pipe")]
            internal static extern int MpvGetWakeupPipe(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_wait_async_requests")]
            internal static extern void MpvWaitAsyncRequests(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_get_sub_api")]
            internal static extern global::System.IntPtr MpvGetSubApi(global::System.IntPtr ctx, global::MPVLib.MpvSubApi sub_api);
        }

        /// <summary>Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with.</summary>
        public static ulong MpvClientApiVersion()
        {
            var __ret = __Internal.MpvClientApiVersion();
            return __ret;
        }

        /// <summary>
        /// <para>Return a string describing the error. For unknown errors, the string</para>
        /// <para>&quot;unknown error&quot; is returned.</para>
        /// </summary>
        /// <param name="error">error number, see enum mpv_error</param>
        /// <returns>
        /// <para>A static string describing the error. The string is completely</para>
        /// <para>static, i.e. doesn't need to be deallocated, and is valid forever.</para>
        /// </returns>
        public static string MpvErrorString(int error)
        {
            var __ret = __Internal.MpvErrorString(error);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>General function to deallocate memory returned by some of the API functions.</para>
        /// <para>Call this only if it's explicitly documented as allowed. Calling this on</para>
        /// <para>mpv memory not owned by the caller will lead to undefined behavior.</para>
        /// </summary>
        /// <param name="data">A valid pointer returned by the API, or NULL.</param>
        public static void MpvFree(global::System.IntPtr data)
        {
            __Internal.MpvFree(data);
        }

        /// <summary>
        /// <para>Return the name of this client handle. Every client has its own unique</para>
        /// <para>name, which is mostly used for user interface purposes.</para>
        /// </summary>
        /// <returns>
        /// <para>The client name. The string is read-only and is valid until the</para>
        /// <para>mpv_handle is destroyed.</para>
        /// </returns>
        public static string MpvClientName(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvClientName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Create a new mpv instance and an associated client API handle to control</para>
        /// <para>the mpv instance. This instance is in a pre-initialized state,</para>
        /// <para>and needs to be initialized to be actually used with most other API</para>
        /// <para>functions.</para>
        /// </summary>
        /// <returns>
        /// <para>a new mpv client API handle. Returns NULL on error. Currently, this</para>
        /// <para>can happen in the following situations:</para>
        /// <para>- out of memory</para>
        /// <para>- LC_NUMERIC is not set to &quot;C&quot; (see general remarks)</para>
        /// </returns>
        /// <remarks>
        /// <para>Some API functions will return MPV_ERROR_UNINITIALIZED in the uninitialized</para>
        /// <para>state. You can call mpv_set_property() (or mpv_set_property_string() and</para>
        /// <para>other variants, and before mpv 0.21.0 mpv_set_option() etc.) to set initial</para>
        /// <para>options. After this, call mpv_initialize() to start the player, and then use</para>
        /// <para>e.g. mpv_command() to start playback of a file.</para>
        /// <para>The point of separating handle creation and actual initialization is that</para>
        /// <para>you can configure things which can't be changed during runtime.</para>
        /// <para>Unlike the command line player, this will have initial settings suitable</para>
        /// <para>for embedding in applications. The following settings are different:</para>
        /// <para>- stdin/stdout/stderr and the terminal will never be accessed. This is</para>
        /// <para>equivalent to setting the --no-terminal option.</para>
        /// <para>(Technically, this also suppresses C signal handling.)</para>
        /// <para>- No config files will be loaded. This is roughly equivalent to using</para>
        /// <para>--config=no. Since libmpv 1.15, you can actually re-enable this option,</para>
        /// <para>which will make libmpv load config files during mpv_initialize(). If you</para>
        /// <para>do this, you are strongly encouraged to set the &quot;config-dir&quot; option too.</para>
        /// <para>(Otherwise it will load the mpv command line player's config.)</para>
        /// <para>For example:</para>
        /// <para>mpv_set_option_string(mpv, &quot;config-dir&quot;, &quot;/my/path&quot;); // set config root</para>
        /// <para>mpv_set_option_string(mpv, &quot;config&quot;, &quot;yes&quot;); // enable config loading</para>
        /// <para>(call mpv_initialize() _after_ this)</para>
        /// <para>- Idle mode is enabled, which means the playback core will enter idle mode</para>
        /// <para>if there are no more files to play on the internal playlist, instead of</para>
        /// <para>exiting. This is equivalent to the --idle option.</para>
        /// <para>- Disable parts of input handling.</para>
        /// <para>- Most of the different settings can be viewed with the command line player</para>
        /// <para>by running &quot;mpv --show-profile=libmpv&quot;.</para>
        /// <para>All this assumes that API users want a mpv instance that is strictly</para>
        /// <para>isolated from the command line player's configuration, user settings, and</para>
        /// <para>so on. You can re-enable disabled features by setting the appropriate</para>
        /// <para>options.</para>
        /// <para>The mpv command line parser is not available through this API, but you can</para>
        /// <para>set individual options with mpv_set_property(). Files for playback must be</para>
        /// <para>loaded with mpv_command() or others.</para>
        /// <para>Note that you should avoid doing concurrent accesses on the uninitialized</para>
        /// <para>client handle. (Whether concurrent access is definitely allowed or not has</para>
        /// <para>yet to be decided.)</para>
        /// </remarks>
        public static global::MPVLib.MpvHandle MpvCreate()
        {
            var __ret = __Internal.MpvCreate();
            global::MPVLib.MpvHandle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::MPVLib.MpvHandle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::MPVLib.MpvHandle) global::MPVLib.MpvHandle.NativeToManagedMap[__ret];
            else __result0 = global::MPVLib.MpvHandle.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Initialize an uninitialized mpv instance. If the mpv instance is already</para>
        /// <para>running, an error is retuned.</para>
        /// </summary>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>This function needs to be called to make full use of the client API if the</para>
        /// <para>client API handle was created with mpv_create().</para>
        /// <para>Only the following options require to be set _before_ mpv_initialize():</para>
        /// <para>- options which are only read at initialization time:</para>
        /// <para>- config</para>
        /// <para>- config-dir</para>
        /// <para>- input-conf</para>
        /// <para>- load-scripts</para>
        /// <para>- script</para>
        /// <para>- player-operation-mode</para>
        /// <para>- input-app-events (OSX)</para>
        /// <para>- all encoding mode options</para>
        /// </remarks>
        public static int MpvInitialize(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvInitialize(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Disconnect and destroy the mpv_handle. ctx will be deallocated with this</para>
        /// <para>API call. This leaves the player running. If you want to be sure that the</para>
        /// <para>player is terminated, send a &quot;quit&quot; command, and wait until the</para>
        /// <para>MPV_EVENT_SHUTDOWN event is received, or use mpv_terminate_destroy().</para>
        /// </summary>
        public static void MpvDetachDestroy(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvDetachDestroy(__arg0);
        }

        /// <summary>
        /// <para>Similar to mpv_detach_destroy(), but brings the player and all clients down</para>
        /// <para>as well, and waits until all of them are destroyed. This function blocks. The</para>
        /// <para>advantage over mpv_detach_destroy() is that while mpv_detach_destroy() merely</para>
        /// <para>detaches the client handle from the player, this function quits the player,</para>
        /// <para>waits until all other clients are destroyed (i.e. all mpv_handles are</para>
        /// <para>detached), and also waits for the final termination of the player.</para>
        /// </summary>
        /// <remarks>
        /// <para>Since mpv_detach_destroy() is called somewhere on the way, it's not safe to</para>
        /// <para>call other functions concurrently on the same context.</para>
        /// <para>If this is called on a mpv_handle that was not created with mpv_create(),</para>
        /// <para>this function will merely send a quit command and then call</para>
        /// <para>mpv_detach_destroy(), without waiting for the actual shutdown.</para>
        /// </remarks>
        public static void MpvTerminateDestroy(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvTerminateDestroy(__arg0);
        }

        /// <summary>
        /// <para>Create a new client handle connected to the same player core as ctx. This</para>
        /// <para>context has its own event queue, its own mpv_request_event() state, its own</para>
        /// <para>mpv_request_log_messages() state, its own set of observed properties, and</para>
        /// <para>its own state for asynchronous operations. Otherwise, everything is shared.</para>
        /// </summary>
        /// <param name="ctx">
        /// <para>Used to get the reference to the mpv core; handle-specific</para>
        /// <para>settings and parameters are not used.</para>
        /// <para>If NULL, this function behaves like mpv_create() (ignores name).</para>
        /// </param>
        /// <param name="name">
        /// <para>The client name. This will be returned by mpv_client_name(). If</para>
        /// <para>the name is already in use, or contains non-alphanumeric</para>
        /// <para>characters (other than '_'), the name is modified to fit.</para>
        /// <para>If NULL, an arbitrary name is automatically chosen.</para>
        /// </param>
        /// <returns>a new handle, or NULL on error</returns>
        /// <remarks>
        /// <para>This handle should be destroyed with mpv_detach_destroy() if no longer</para>
        /// <para>needed. The core will live as long as there is at least 1 handle referencing</para>
        /// <para>it. Any handle can make the core quit, which will result in every handle</para>
        /// <para>receiving MPV_EVENT_SHUTDOWN.</para>
        /// <para>This function can not be called before the main handle was initialized with</para>
        /// <para>mpv_initialize(). The new handle is always initialized, unless ctx=NULL was</para>
        /// <para>passed.</para>
        /// </remarks>
        public static global::MPVLib.MpvHandle MpvCreateClient(global::MPVLib.MpvHandle ctx, string name)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvCreateClient(__arg0, name);
            global::MPVLib.MpvHandle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::MPVLib.MpvHandle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::MPVLib.MpvHandle) global::MPVLib.MpvHandle.NativeToManagedMap[__ret];
            else __result0 = global::MPVLib.MpvHandle.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Load a config file. This loads and parses the file, and sets every entry in</para>
        /// <para>the config file's default section as if mpv_set_option_string() is called.</para>
        /// </summary>
        /// <param name="filename">absolute path to the config file on the local filesystem</param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>The filename should be an absolute path. If it isn't, the actual path used</para>
        /// <para>is unspecified. (Note: an absolute path starts with '/' on UNIX.) If the</para>
        /// <para>file wasn't found, MPV_ERROR_INVALID_PARAMETER is returned.</para>
        /// <para>If a fatal error happens when parsing a config file, MPV_ERROR_OPTION_ERROR</para>
        /// <para>is returned. Errors when setting options as well as other types or errors</para>
        /// <para>are ignored (even if options do not exist). You can still try to capture</para>
        /// <para>the resulting error messages with mpv_request_log_messages(). Note that it's</para>
        /// <para>possible that some options were successfully set even if any of these errors</para>
        /// <para>happen.</para>
        /// </remarks>
        public static int MpvLoadConfigFile(global::MPVLib.MpvHandle ctx, string filename)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvLoadConfigFile(__arg0, filename);
            return __ret;
        }

        /// <summary>
        /// <para>This does nothing since mpv 0.23.0 (API version 1.24). Below is the</para>
        /// <para>description of the old behavior.</para>
        /// </summary>
        /// <remarks>
        /// <para>Stop the playback thread. This means the core will stop doing anything, and</para>
        /// <para>only run and answer to client API requests. This is sometimes useful; for</para>
        /// <para>example, no new frame will be queued to the video output, so doing requests</para>
        /// <para>which have to wait on the video output can run instantly.</para>
        /// <para>Suspension is reentrant and recursive for convenience. Any thread can call</para>
        /// <para>the suspend function multiple times, and the playback thread will remain</para>
        /// <para>suspended until the last thread resumes it. Note that during suspension, all</para>
        /// <para>clients still have concurrent access to the core, which is serialized through</para>
        /// <para>a single mutex.</para>
        /// <para>Call mpv_resume() to resume the playback thread. You must call mpv_resume()</para>
        /// <para>for each mpv_suspend() call. Calling mpv_resume() more often than</para>
        /// <para>mpv_suspend() is not allowed.</para>
        /// <para>Calling this on an uninitialized player (see mpv_create()) will deadlock.</para>
        /// <para>This function, as well as mpv_resume(), are deprecated, and</para>
        /// <para>will stop doing anything soon. Their semantics were never</para>
        /// <para>well-defined, and their usefulness is extremely limited. The</para>
        /// <para>calls will remain stubs in order to keep ABI compatibility.</para>
        /// </remarks>
        public static void MpvSuspend(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvSuspend(__arg0);
        }

        /// <summary>See mpv_suspend().</summary>
        public static void MpvResume(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvResume(__arg0);
        }

        /// <summary>
        /// <para>Return the internal time in microseconds. This has an arbitrary start offset,</para>
        /// <para>but will never wrap or go backwards.</para>
        /// </summary>
        /// <remarks>
        /// <para>Note that this is always the real time, and doesn't necessarily have to do</para>
        /// <para>with playback time. For example, playback could go faster or slower due to</para>
        /// <para>playback speed, or due to playback being paused. Use the &quot;time-pos&quot; property</para>
        /// <para>instead to get the playback status.</para>
        /// <para>Unlike other libmpv APIs, this can be called at absolutely any time (even</para>
        /// <para>within wakeup callbacks), as long as the context is valid.</para>
        /// </remarks>
        public static long MpvGetTimeUs(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetTimeUs(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Frees any data referenced by the node. It doesn't free the node itself.</para>
        /// <para>Call this only if the mpv client API set the node. If you constructed the</para>
        /// <para>node yourself (manually), you have to free it yourself.</para>
        /// </summary>
        /// <remarks>
        /// <para>If node-&gt;format is MPV_FORMAT_NONE, this call does nothing. Likewise, if</para>
        /// <para>the client API sets a node with this format, this function doesn't need to</para>
        /// <para>be called. (This is just a clarification that there's no danger of anything</para>
        /// <para>strange happening in these cases.)</para>
        /// </remarks>
        public static void MpvFreeNodeContents(global::MPVLib.MpvNode node)
        {
            var __arg0 = ReferenceEquals(node, null) ? global::System.IntPtr.Zero : node.__Instance;
            __Internal.MpvFreeNodeContents(__arg0);
        }

        /// <summary>
        /// <para>Set an option. Note that you can't normally set options during runtime. It</para>
        /// <para>works in uninitialized state (see mpv_create()), and in some cases in at</para>
        /// <para>runtime.</para>
        /// </summary>
        /// <param name="name">
        /// <para>Option name. This is the same as on the mpv command line, but</para>
        /// <para>without the leading &quot;--&quot;.</para>
        /// </param>
        /// <param name="format">see enum mpv_format.</param>
        /// <param name="data">Option value (according to the format).</param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>Using a format other than MPV_FORMAT_NODE is equivalent to constructing a</para>
        /// <para>mpv_node with the given format and data, and passing the mpv_node to this</para>
        /// <para>function.</para>
        /// <para>Note: this is semi-deprecated. For most purposes, this is not needed anymore.</para>
        /// <para>Starting with mpv version 0.21.0 (version 1.23) most options can be set</para>
        /// <para>with mpv_set_property() (and related functions), and even before</para>
        /// <para>mpv_initialize(). In some obscure corner cases, using this function</para>
        /// <para>to set options might still be required (see below, and also section</para>
        /// <para>&quot;Inconsistencies between options and properties&quot; on the manpage). Once</para>
        /// <para>these are resolved, the option setting functions might be fully</para>
        /// <para>deprecated.</para>
        /// <para>The following options still need to be set either _before_</para>
        /// <para>mpv_initialize() with mpv_set_property() (or related functions), or</para>
        /// <para>with mpv_set_option() (or related functions) at any time:</para>
        /// <para>- options shadowed by deprecated properties:</para>
        /// <para>- demuxer (property deprecated in 0.21.0)</para>
        /// <para>- idle (property deprecated in 0.21.0)</para>
        /// <para>- fps (property deprecated in 0.21.0)</para>
        /// <para>- cache (property deprecated in 0.21.0)</para>
        /// <para>- length (property deprecated in 0.10.0)</para>
        /// <para>- audio-samplerate (property deprecated in 0.10.0)</para>
        /// <para>- audio-channels (property deprecated in 0.10.0)</para>
        /// <para>- audio-format (property deprecated in 0.10.0)</para>
        /// <para>- deprecated options shadowed by properties:</para>
        /// <para>- chapter (option deprecated in 0.21.0)</para>
        /// <para>- playlist-pos (option deprecated in 0.21.0)</para>
        /// <para>The deprecated properties were removed in mpv 0.23.0.</para>
        /// </remarks>
        public static int MpvSetOption(global::MPVLib.MpvHandle ctx, string name, global::MPVLib.MpvFormat format, global::System.IntPtr data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvSetOption(__arg0, name, format, data);
            return __ret;
        }

        /// <summary>
        /// <para>Convenience function to set an option to a string value. This is like</para>
        /// <para>calling mpv_set_option() with MPV_FORMAT_STRING.</para>
        /// </summary>
        /// <returns>error code</returns>
        public static int MpvSetOptionString(global::MPVLib.MpvHandle ctx, string name, string data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvSetOptionString(__arg0, name, data);
            return __ret;
        }

        /// <summary>
        /// <para>Send a command to the player. Commands are the same as those used in</para>
        /// <para>input.conf, except that this function takes parameters in a pre-split</para>
        /// <para>form.</para>
        /// </summary>
        /// <param name="args">
        /// <para>NULL-terminated list of strings. Usually, the first item</para>
        /// <para>is the command, and the following items are arguments.</para>
        /// </param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>The commands and their parameters are documented in input.rst.</para>
        /// <para>Does not use OSD and string expansion by default (unlike mpv_command_string()</para>
        /// <para>and input.conf).</para>
        /// </remarks>
        public static int MpvCommand(global::MPVLib.MpvHandle ctx, sbyte** args)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvCommand(__arg0, args);
            return __ret;
        }

        /// <summary>
        /// <para>Same as mpv_command(), but allows passing structured data in any format.</para>
        /// <para>In particular, calling mpv_command() is exactly like calling</para>
        /// <para>mpv_command_node() with the format set to MPV_FORMAT_NODE_ARRAY, and</para>
        /// <para>every arg passed in order as MPV_FORMAT_STRING.</para>
        /// </summary>
        /// <param name="args">
        /// <para>mpv_node with format set to MPV_FORMAT_NODE_ARRAY; each entry</para>
        /// <para>is an argument using an arbitrary format (the format must be</para>
        /// <para>compatible to the used command). Usually, the first item is</para>
        /// <para>the command name (as MPV_FORMAT_STRING).</para>
        /// </param>
        /// <param name="result">
        /// <para>Optional, pass NULL if unused. If not NULL, and if the</para>
        /// <para>function succeeds, this is set to command-specific return</para>
        /// <para>data. You must call mpv_free_node_contents() to free it</para>
        /// <para>(again, only if the command actually succeeds).</para>
        /// <para>Not many commands actually use this at all.</para>
        /// </param>
        /// <returns>error code (the result parameter is not set on error)</returns>
        /// <remarks>Does not use OSD and string expansion by default.</remarks>
        public static int MpvCommandNode(global::MPVLib.MpvHandle ctx, global::MPVLib.MpvNode args, global::MPVLib.MpvNode result)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = ReferenceEquals(args, null) ? global::System.IntPtr.Zero : args.__Instance;
            var __arg2 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
            var __ret = __Internal.MpvCommandNode(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Same as mpv_command, but use input.conf parsing for splitting arguments.</para>
        /// <para>This is slightly simpler, but also more error prone, since arguments may</para>
        /// <para>need quoting/escaping.</para>
        /// </summary>
        /// <remarks>This also has OSD and string expansion enabled by default.</remarks>
        public static int MpvCommandString(global::MPVLib.MpvHandle ctx, string args)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvCommandString(__arg0, args);
            return __ret;
        }

        /// <summary>Same as mpv_command, but run the command asynchronously.</summary>
        /// <param name="reply_userdata">
        /// <para>the value mpv_event.reply_userdata of the reply will</para>
        /// <para>be set to (see section about asynchronous calls)</para>
        /// </param>
        /// <param name="args">NULL-terminated list of strings (see mpv_command())</param>
        /// <returns>error code (if parsing or queuing the command fails)</returns>
        /// <remarks>
        /// <para>Commands are executed asynchronously. You will receive a</para>
        /// <para>MPV_EVENT_COMMAND_REPLY event. (This event will also have an</para>
        /// <para>error code set if running the command failed.)</para>
        /// <para>This has nothing to do with the &quot;async&quot; command prefix, although they might</para>
        /// <para>be unified in the future. For now, calling this API means that the command</para>
        /// <para>will be synchronously executed on the core, without blocking the API user.</para>
        /// </remarks>
        public static int MpvCommandAsync(global::MPVLib.MpvHandle ctx, ulong reply_userdata, sbyte** args)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvCommandAsync(__arg0, reply_userdata, args);
            return __ret;
        }

        /// <summary>
        /// <para>Same as mpv_command_node(), but run it asynchronously. Basically, this</para>
        /// <para>function is to mpv_command_node() what mpv_command_async() is to</para>
        /// <para>mpv_command().</para>
        /// </summary>
        /// <param name="reply_userdata">
        /// <para>the value mpv_event.reply_userdata of the reply will</para>
        /// <para>be set to (see section about asynchronous calls)</para>
        /// </param>
        /// <param name="args">as in mpv_command_node()</param>
        /// <returns>error code (if parsing or queuing the command fails)</returns>
        /// <remarks>
        /// <para>See mpv_command_async() for details. Retrieving the result is not</para>
        /// <para>supported yet.</para>
        /// </remarks>
        public static int MpvCommandNodeAsync(global::MPVLib.MpvHandle ctx, ulong reply_userdata, global::MPVLib.MpvNode args)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg2 = ReferenceEquals(args, null) ? global::System.IntPtr.Zero : args.__Instance;
            var __ret = __Internal.MpvCommandNodeAsync(__arg0, reply_userdata, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Set a property to a given value. Properties are essentially variables which</para>
        /// <para>can be queried or set at runtime. For example, writing to the pause property</para>
        /// <para>will actually pause or unpause playback.</para>
        /// </summary>
        /// <param name="name">The property name. See input.rst for a list of properties.</param>
        /// <param name="format">see enum mpv_format.</param>
        /// <param name="data">Option value.</param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>If the format doesn't match with the internal format of the property, access</para>
        /// <para>usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data</para>
        /// <para>is automatically converted and access succeeds. For example, MPV_FORMAT_INT64</para>
        /// <para>is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING</para>
        /// <para>usually invokes a string parser. The same happens when calling this function</para>
        /// <para>with MPV_FORMAT_NODE: the underlying format may be converted to another</para>
        /// <para>type if possible.</para>
        /// <para>Using a format other than MPV_FORMAT_NODE is equivalent to constructing a</para>
        /// <para>mpv_node with the given format and data, and passing the mpv_node to this</para>
        /// <para>function. (Before API version 1.21, this was different.)</para>
        /// <para>Note: starting with mpv 0.21.0 (client API version 1.23), this can be used to</para>
        /// <para>set options in general. It even can be used before mpv_initialize()</para>
        /// <para>has been called. If called before mpv_initialize(), setting properties</para>
        /// <para>not backed by options will result in MPV_ERROR_PROPERTY_UNAVAILABLE.</para>
        /// <para>In some cases, properties and options still conflict. In these cases,</para>
        /// <para>mpv_set_property() accesses the options before mpv_initialize(), and</para>
        /// <para>the properties after mpv_initialize(). These conflicts will be removed</para>
        /// <para>in mpv 0.23.0. See mpv_set_option() for further remarks.</para>
        /// </remarks>
        public static int MpvSetProperty(global::MPVLib.MpvHandle ctx, string name, global::MPVLib.MpvFormat format, global::System.IntPtr data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvSetProperty(__arg0, name, format, data);
            return __ret;
        }

        /// <summary>Convenience function to set a property to a string value.</summary>
        /// <remarks>This is like calling mpv_set_property() with MPV_FORMAT_STRING.</remarks>
        public static int MpvSetPropertyString(global::MPVLib.MpvHandle ctx, string name, string data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvSetPropertyString(__arg0, name, data);
            return __ret;
        }

        /// <summary>
        /// <para>Set a property asynchronously. You will receive the result of the operation</para>
        /// <para>as MPV_EVENT_SET_PROPERTY_REPLY event. The mpv_event.error field will contain</para>
        /// <para>the result status of the operation. Otherwise, this function is similar to</para>
        /// <para>mpv_set_property().</para>
        /// </summary>
        /// <param name="reply_userdata">see section about asynchronous calls</param>
        /// <param name="name">The property name.</param>
        /// <param name="format">see enum mpv_format.</param>
        /// <param name="data">
        /// <para>Option value. The value will be copied by the function. It</para>
        /// <para>will never be modified by the client API.</para>
        /// </param>
        /// <returns>error code if sending the request failed</returns>
        public static int MpvSetPropertyAsync(global::MPVLib.MpvHandle ctx, ulong reply_userdata, string name, global::MPVLib.MpvFormat format, global::System.IntPtr data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvSetPropertyAsync(__arg0, reply_userdata, name, format, data);
            return __ret;
        }

        /// <summary>Read the value of the given property.</summary>
        /// <param name="name">The property name.</param>
        /// <param name="format">see enum mpv_format.</param>
        /// <param name="data">
        /// <para>Pointer to the variable holding the option value. On</para>
        /// <para>success, the variable will be set to a copy of the option</para>
        /// <para>value. For formats that require dynamic memory allocation,</para>
        /// <para>you can free the value with mpv_free() (strings) or</para>
        /// <para>mpv_free_node_contents() (MPV_FORMAT_NODE).</para>
        /// </param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>If the format doesn't match with the internal format of the property, access</para>
        /// <para>usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data</para>
        /// <para>is automatically converted and access succeeds. For example, MPV_FORMAT_INT64</para>
        /// <para>is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING</para>
        /// <para>usually invokes a string formatter.</para>
        /// </remarks>
        public static int MpvGetProperty(global::MPVLib.MpvHandle ctx, string name, global::MPVLib.MpvFormat format, global::System.IntPtr data)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetProperty(__arg0, name, format, data);
            return __ret;
        }

        /// <summary>
        /// <para>Return the value of the property with the given name as string. This is</para>
        /// <para>equivalent to mpv_get_property() with MPV_FORMAT_STRING.</para>
        /// </summary>
        /// <param name="name">The property name.</param>
        /// <returns>
        /// <para>Property value, or NULL if the property can't be retrieved. Free</para>
        /// <para>the string with mpv_free().</para>
        /// </returns>
        /// <remarks>
        /// <para>See MPV_FORMAT_STRING for character encoding issues.</para>
        /// <para>On error, NULL is returned. Use mpv_get_property() if you want fine-grained</para>
        /// <para>error reporting.</para>
        /// </remarks>
        public static sbyte* MpvGetPropertyString(global::MPVLib.MpvHandle ctx, string name)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetPropertyString(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Return the property as &quot;OSD&quot; formatted string. This is the same as</para>
        /// <para>mpv_get_property_string, but using MPV_FORMAT_OSD_STRING.</para>
        /// </summary>
        /// <returns>
        /// <para>Property value, or NULL if the property can't be retrieved. Free</para>
        /// <para>the string with mpv_free().</para>
        /// </returns>
        public static sbyte* MpvGetPropertyOsdString(global::MPVLib.MpvHandle ctx, string name)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetPropertyOsdString(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Get a property asynchronously. You will receive the result of the operation</para>
        /// <para>as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event.</para>
        /// <para>You should check the mpv_event.error field on the reply event.</para>
        /// </summary>
        /// <param name="reply_userdata">see section about asynchronous calls</param>
        /// <param name="name">The property name.</param>
        /// <param name="format">see enum mpv_format.</param>
        /// <returns>error code if sending the request failed</returns>
        public static int MpvGetPropertyAsync(global::MPVLib.MpvHandle ctx, ulong reply_userdata, string name, global::MPVLib.MpvFormat format)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetPropertyAsync(__arg0, reply_userdata, name, format);
            return __ret;
        }

        /// <summary>
        /// <para>Get a notification whenever the given property changes. You will receive</para>
        /// <para>updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise:</para>
        /// <para>for some properties, it may not send updates even if the property changed.</para>
        /// <para>This depends on the property, and it's a valid feature request to ask for</para>
        /// <para>better update handling of a specific property. (For some properties, like</para>
        /// <para>``clock``, which shows the wall clock, this mechanism doesn't make too</para>
        /// <para>much sense anyway.)</para>
        /// </summary>
        /// <param name="reply_userdata">
        /// <para>This will be used for the mpv_event.reply_userdata</para>
        /// <para>field for the received MPV_EVENT_PROPERTY_CHANGE</para>
        /// <para>events. (Also see section about asynchronous calls,</para>
        /// <para>although this function is somewhat different from</para>
        /// <para>actual asynchronous calls.)</para>
        /// <para>If you have no use for this, pass 0.</para>
        /// <para>Also see mpv_unobserve_property().</para>
        /// </param>
        /// <param name="name">The property name.</param>
        /// <param name="format">
        /// <para>see enum mpv_format. Can be MPV_FORMAT_NONE to omit values</para>
        /// <para>from the change events.</para>
        /// </param>
        /// <returns>error code (usually fails only on OOM or unsupported format)</returns>
        /// <remarks>
        /// <para>Property changes are coalesced: the change events are returned only once the</para>
        /// <para>event queue becomes empty (e.g. mpv_wait_event() would block or return</para>
        /// <para>MPV_EVENT_NONE), and then only one event per changed property is returned.</para>
        /// <para>Normally, change events are sent only if the property value changes according</para>
        /// <para>to the requested format. mpv_event_property will contain the property value</para>
        /// <para>as data member.</para>
        /// <para>Warning: if a property is unavailable or retrieving it caused an error,</para>
        /// <para>MPV_FORMAT_NONE will be set in mpv_event_property, even if the</para>
        /// <para>format parameter was set to a different value. In this case, the</para>
        /// <para>mpv_event_property.data field is invalid.</para>
        /// <para>If the property is observed with the format parameter set to MPV_FORMAT_NONE,</para>
        /// <para>you get low-level notifications whether the property _may_ have changed, and</para>
        /// <para>the data member in mpv_event_property will be unset. With this mode, you</para>
        /// <para>will have to determine yourself whether the property really changd. On the</para>
        /// <para>other hand, this mechanism can be faster and uses less resources.</para>
        /// <para>Observing a property that doesn't exist is allowed. (Although it may still</para>
        /// <para>cause some sporadic change events.)</para>
        /// <para>Keep in mind that you will get change notifications even if you change a</para>
        /// <para>property yourself. Try to avoid endless feedback loops, which could happen</para>
        /// <para>if you react to the change notifications triggered by your own change.</para>
        /// </remarks>
        public static int MpvObserveProperty(global::MPVLib.MpvHandle mpv, ulong reply_userdata, string name, global::MPVLib.MpvFormat format)
        {
            var __arg0 = ReferenceEquals(mpv, null) ? global::System.IntPtr.Zero : mpv.__Instance;
            var __ret = __Internal.MpvObserveProperty(__arg0, reply_userdata, name, format);
            return __ret;
        }

        /// <summary>
        /// <para>Undo mpv_observe_property(). This will remove all observed properties for</para>
        /// <para>which the given number was passed as reply_userdata to mpv_observe_property.</para>
        /// </summary>
        /// <param name="registered_reply_userdata">ID that was passed to mpv_observe_property</param>
        /// <returns>
        /// <para>negative value is an error code, &gt;=0 is number of removed properties</para>
        /// <para>on success (includes the case when 0 were removed)</para>
        /// </returns>
        public static int MpvUnobserveProperty(global::MPVLib.MpvHandle mpv, ulong registered_reply_userdata)
        {
            var __arg0 = ReferenceEquals(mpv, null) ? global::System.IntPtr.Zero : mpv.__Instance;
            var __ret = __Internal.MpvUnobserveProperty(__arg0, registered_reply_userdata);
            return __ret;
        }

        /// <summary>Return a string describing the event. For unknown events, NULL is returned.</summary>
        /// <param name="event">event ID, see see enum mpv_event_id</param>
        /// <returns>
        /// <para>A static string giving a short symbolic name of the event. It</para>
        /// <para>consists of lower-case alphanumeric characters and can include &quot;-&quot;</para>
        /// <para>characters. This string is suitable for use in e.g. scripting</para>
        /// <para>interfaces.</para>
        /// <para>The string is completely static, i.e. doesn't need to be deallocated,</para>
        /// <para>and is valid forever.</para>
        /// </returns>
        /// <remarks>
        /// <para>Note that all events actually returned by the API will also yield a non-NULL</para>
        /// <para>string with this function.</para>
        /// </remarks>
        public static string MpvEventName(global::MPVLib.MpvEventId @event)
        {
            var __ret = __Internal.MpvEventName(@event);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Enable or disable the given event.</summary>
        /// <param name="event">See enum mpv_event_id.</param>
        /// <param name="enable">1 to enable receiving this event, 0 to disable it.</param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>Some events are enabled by default. Some events can't be disabled.</para>
        /// <para>(Informational note: currently, all events are enabled by default, except</para>
        /// <para>MPV_EVENT_TICK.)</para>
        /// </remarks>
        public static int MpvRequestEvent(global::MPVLib.MpvHandle ctx, global::MPVLib.MpvEventId @event, int enable)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvRequestEvent(__arg0, @event, enable);
            return __ret;
        }

        /// <summary>
        /// <para>Enable or disable receiving of log messages. These are the messages the</para>
        /// <para>command line player prints to the terminal. This call sets the minimum</para>
        /// <para>required log level for a message to be received with MPV_EVENT_LOG_MESSAGE.</para>
        /// </summary>
        /// <param name="min_level">
        /// <para>Minimal log level as string. Valid log levels:</para>
        /// <para>no fatal error warn info v debug trace</para>
        /// <para>The value &quot;no&quot; disables all messages. This is the default.</para>
        /// <para>An exception is the value &quot;terminal-default&quot;, which uses the</para>
        /// <para>log level as set by the &quot;--msg-level&quot; option. This works</para>
        /// <para>even if the terminal is disabled. (Since API version 1.19.)</para>
        /// <para>Also see mpv_log_level.</para>
        /// </param>
        /// <returns>error code</returns>
        public static int MpvRequestLogMessages(global::MPVLib.MpvHandle ctx, string min_level)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvRequestLogMessages(__arg0, min_level);
            return __ret;
        }

        /// <summary>
        /// <para>Wait for the next event, or until the timeout expires, or if another thread</para>
        /// <para>makes a call to mpv_wakeup(). Passing 0 as timeout will never wait, and</para>
        /// <para>is suitable for polling.</para>
        /// </summary>
        /// <param name="timeout">
        /// <para>Timeout in seconds, after which the function returns even if</para>
        /// <para>no event was received. A MPV_EVENT_NONE is returned on</para>
        /// <para>timeout. A value of 0 will disable waiting. Negative values</para>
        /// <para>will wait with an infinite timeout.</para>
        /// </param>
        /// <returns>
        /// <para>A struct containing the event ID and other data. The pointer (and</para>
        /// <para>fields in the struct) stay valid until the next mpv_wait_event()</para>
        /// <para>call, or until the mpv_handle is destroyed. You must not write to</para>
        /// <para>the struct, and all memory referenced by it will be automatically</para>
        /// <para>released by the API on the next mpv_wait_event() call, or when the</para>
        /// <para>context is destroyed. The return value is never NULL.</para>
        /// </returns>
        /// <remarks>
        /// <para>The internal event queue has a limited size (per client handle). If you</para>
        /// <para>don't empty the event queue quickly enough with mpv_wait_event(), it will</para>
        /// <para>overflow and silently discard further events. If this happens, making</para>
        /// <para>asynchronous requests will fail as well (with MPV_ERROR_EVENT_QUEUE_FULL).</para>
        /// <para>Only one thread is allowed to call this on the same mpv_handle at a time.</para>
        /// <para>The API won't complain if more than one thread calls this, but it will cause</para>
        /// <para>race conditions in the client when accessing the shared mpv_event struct.</para>
        /// <para>Note that most other API functions are not restricted by this, and no API</para>
        /// <para>function internally calls mpv_wait_event(). Additionally, concurrent calls</para>
        /// <para>to different mpv_handles are always safe.</para>
        /// </remarks>
        public static global::MPVLib.MpvEvent MpvWaitEvent(global::MPVLib.MpvHandle ctx, double timeout)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvWaitEvent(__arg0, timeout);
            global::MPVLib.MpvEvent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::MPVLib.MpvEvent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::MPVLib.MpvEvent) global::MPVLib.MpvEvent.NativeToManagedMap[__ret];
            else __result0 = global::MPVLib.MpvEvent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Interrupt the current mpv_wait_event() call. This will wake up the thread</para>
        /// <para>currently waiting in mpv_wait_event(). If no thread is waiting, the next</para>
        /// <para>mpv_wait_event() call will return immediately (this is to avoid lost</para>
        /// <para>wakeups).</para>
        /// </summary>
        /// <remarks>
        /// <para>mpv_wait_event() will receive a MPV_EVENT_NONE if it's woken up due to</para>
        /// <para>this call. But note that this dummy event might be skipped if there are</para>
        /// <para>already other events queued. All what counts is that the waiting thread</para>
        /// <para>is woken up at all.</para>
        /// </remarks>
        public static void MpvWakeup(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvWakeup(__arg0);
        }

        /// <summary>
        /// <para>Set a custom function that should be called when there are new events. Use</para>
        /// <para>this if blocking in mpv_wait_event() to wait for new events is not feasible.</para>
        /// </summary>
        /// <param name="cb">function that should be called if a wakeup is required</param>
        /// <param name="d">arbitrary userdata passed to cb</param>
        /// <remarks>
        /// <para>Keep in mind that the callback will be called from foreign threads. You</para>
        /// <para>must not make any assumptions of the environment, and you must return as</para>
        /// <para>soon as possible. You are not allowed to call any client API functions</para>
        /// <para>inside of the callback. In particular, you should not do any processing in</para>
        /// <para>the callback, but wake up another thread that does all the work. It's also</para>
        /// <para>possible that the callback is called from a thread while a mpv API function</para>
        /// <para>is called (i.e. it can be reentrant).</para>
        /// <para>In general, the client API expects you to call mpv_wait_event() to receive</para>
        /// <para>notifications, and the wakeup callback is merely a helper utility to make</para>
        /// <para>this easier in certain situations. Note that it's possible that there's</para>
        /// <para>only one wakeup callback invocation for multiple events. You should call</para>
        /// <para>mpv_wait_event() with no timeout until MPV_EVENT_NONE is reached, at which</para>
        /// <para>point the event queue is empty.</para>
        /// <para>If you actually want to do processing in a callback, spawn a thread that</para>
        /// <para>does nothing but call mpv_wait_event() in a loop and dispatches the result</para>
        /// <para>to a callback.</para>
        /// <para>Only one wakeup callback can be set.</para>
        /// </remarks>
        public static void MpvSetWakeupCallback(global::MPVLib.MpvHandle ctx, global::MPVLib.Delegates.Action_IntPtr cb, global::System.IntPtr d)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.MpvSetWakeupCallback(__arg0, __arg1, d);
        }

        /// <summary>
        /// <para>Return a UNIX file descriptor referring to the read end of a pipe. This</para>
        /// <para>pipe can be used to wake up a poll() based processing loop. The purpose of</para>
        /// <para>this function is very similar to mpv_set_wakeup_callback(), and provides</para>
        /// <para>a primitive mechanism to handle coordinating a foreign event loop and the</para>
        /// <para>libmpv event loop. The pipe is non-blocking. It's closed when the mpv_handle</para>
        /// <para>is destroyed. This function always returns the same value (on success).</para>
        /// </summary>
        /// <returns>
        /// <para>A UNIX FD of the read end of the wakeup pipe, or -1 on error.</para>
        /// <para>On MS Windows/MinGW, this will always return -1.</para>
        /// </returns>
        /// <remarks>
        /// <para>This is in fact implemented using the same underlying code as for</para>
        /// <para>mpv_set_wakeup_callback() (though they don't conflict), and it is as if each</para>
        /// <para>callback invocation writes a single 0 byte to the pipe. When the pipe</para>
        /// <para>becomes readable, the code calling poll() (or select()) on the pipe should</para>
        /// <para>read all contents of the pipe and then call mpv_wait_event(c, 0) until</para>
        /// <para>no new events are returned. The pipe contents do not matter and can just</para>
        /// <para>be discarded. There is not necessarily one byte per readable event in the</para>
        /// <para>pipe. For example, the pipes are non-blocking, and mpv won't block if the</para>
        /// <para>pipe is full. Pipes are normally limited to 4096 bytes, so if there are</para>
        /// <para>more than 4096 events, the number of readable bytes can not equal the number</para>
        /// <para>of events queued. Also, it's possible that mpv does not write to the pipe</para>
        /// <para>once it's guaranteed that the client was already signaled. See the example</para>
        /// <para>below how to do it correctly.</para>
        /// <para>Example:</para>
        /// <para>int pipefd = mpv_get_wakeup_pipe(mpv);</para>
        /// <para>if (pipefd&lt;&gt;0)</para>
        /// <para>error();</para>
        /// <para>while (1) {</para>
        /// <para>struct pollfd pfds[1] = {</para>
        /// <para>{ .fd = pipefd, .events = POLLIN },</para>
        /// <para>};</para>
        /// <para>// Wait until there are possibly new mpv events.</para>
        /// <para>poll(pfds, 1, -1);</para>
        /// <para>if (pfds[0].revents&amp;POLLIN) {</para>
        /// <para>// Empty the pipe. Doing this before calling mpv_wait_event()</para>
        /// <para>// ensures that no wakeups are missed. It's not so important to</para>
        /// <para>// make sure the pipe is really empty (it will just cause some</para>
        /// <para>// additional wakeups in unlikely corner cases).</para>
        /// <para>char unused[256];</para>
        /// <para>read(pipefd, unused, sizeof(unused));</para>
        /// <para>while (1) {</para>
        /// <para>mpv_event *ev = mpv_wait_event(mpv, 0);</para>
        /// <para>// If MPV_EVENT_NONE is received, the event queue is empty.</para>
        /// <para>if (ev-&gt;event_id == MPV_EVENT_NONE)</para>
        /// <para>break;</para>
        /// <para>// Process the event.</para>
        /// <para>...</para>
        /// <para>}</para>
        /// <para>}</para>
        /// <para>}</para>
        /// </remarks>
        public static int MpvGetWakeupPipe(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetWakeupPipe(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Block until all asynchronous requests are done. This affects functions like</para>
        /// <para>mpv_command_async(), which return immediately and return their result as</para>
        /// <para>events.</para>
        /// </summary>
        /// <remarks>
        /// <para>This is a helper, and somewhat equivalent to calling mpv_wait_event() in a</para>
        /// <para>loop until all known asynchronous requests have sent their reply as event,</para>
        /// <para>except that the event queue is not emptied.</para>
        /// <para>In case you called mpv_suspend() before, this will also forcibly reset the</para>
        /// <para>suspend counter of the given handle.</para>
        /// </remarks>
        public static void MpvWaitAsyncRequests(global::MPVLib.MpvHandle ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.MpvWaitAsyncRequests(__arg0);
        }

        /// <summary>
        /// <para>This is used for additional APIs that are not strictly part of the core API.</para>
        /// <para>See the individual mpv_sub_api member values.</para>
        /// </summary>
        public static global::System.IntPtr MpvGetSubApi(global::MPVLib.MpvHandle ctx, global::MPVLib.MpvSubApi sub_api)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvGetSubApi(__arg0, sub_api);
            return __ret;
        }
    }

    /// <summary>Opaque context, returned by mpv_get_sub_api(MPV_SUB_API_OPENGL_CB).</summary>
    /// <remarks>
    /// <para>A context is bound to the mpv_handle it was retrieved from. The context</para>
    /// <para>will always be the same (for the same mpv_handle), and is valid until the</para>
    /// <para>mpv_handle it belongs to is released.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void MpvOpenglCbUpdateFn(global::System.IntPtr cb_ctx);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr MpvOpenglCbGetProcAddressFn(global::System.IntPtr fn_ctx, [MarshalAs(UnmanagedType.LPStr)] string name);

    /// <summary>
    /// <para>Overview</para>
    /// <para>--------</para>
    /// </summary>
    /// <remarks>
    /// <para>This API can be used to make mpv render into a foreign OpenGL context. It</para>
    /// <para>can be used to handle video display.</para>
    /// <para>The renderer needs to be explicitly initialized with mpv_opengl_cb_init_gl(),</para>
    /// <para>and then video can be drawn with mpv_opengl_cb_draw(). The user thread can</para>
    /// <para>be notified by new frames with mpv_opengl_cb_set_update_callback().</para>
    /// <para>You can output and embed video without this API by setting the mpv &quot;wid&quot;</para>
    /// <para>option to a native window handle (see &quot;Embedding the video window&quot; section</para>
    /// <para>in the client.h header). In general, using the opengl-cb API is recommended,</para>
    /// <para>because window embedding can cause various issues, especially with GUI</para>
    /// <para>toolkits and certain platforms.</para>
    /// <para>OpenGL interop</para>
    /// <para>--------------</para>
    /// <para>This assumes the OpenGL context lives on a certain thread controlled by the</para>
    /// <para>API user. The following functions require access to the OpenGL context:</para>
    /// <para>mpv_opengl_cb_init_gl</para>
    /// <para>mpv_opengl_cb_draw</para>
    /// <para>mpv_opengl_cb_uninit_gl</para>
    /// <para>The OpenGL context is indirectly accessed through the OpenGL function</para>
    /// <para>pointers returned by the get_proc_address callback in mpv_opengl_cb_init_gl.</para>
    /// <para>Generally, mpv will not load the system OpenGL library when using this API.</para>
    /// <para>Only &quot;desktop&quot; OpenGL version 2.1 or later is supported. With OpenGL 2.1,</para>
    /// <para>the GL_ARB_texture_rg is required. The renderer was written against</para>
    /// <para>OpenGL 3.x core profile, with additional support for OpenGL 2.1.</para>
    /// <para>Note that some hardware decoding interop API (as set with the &quot;hwdec&quot; option)</para>
    /// <para>may actually access</para>
    /// <para>OpenGL state</para>
    /// <para>------------</para>
    /// <para>OpenGL has a large amount of implicit state. All the mpv functions mentioned</para>
    /// <para>above expect that the OpenGL state is reasonably set to OpenGL standard</para>
    /// <para>defaults. Likewise, mpv will attempt to leave the OpenGL context with</para>
    /// <para>standard defaults. The following state is excluded from this:</para>
    /// <para>- the glViewport state</para>
    /// <para>- the glScissor state (but GL_SCISSOR_TEST is in its default value)</para>
    /// <para>- glBlendFuncSeparate() state (but GL_BLEND is in its default value)</para>
    /// <para>- glClearColor() state</para>
    /// <para>- mpv may overwrite the callback set with glDebugMessageCallback()</para>
    /// <para>- mpv always disables GL_DITHER at init</para>
    /// <para>Messing with the state could be avoided by creating shared OpenGL contexts,</para>
    /// <para>but this is avoided for the sake of compatibility and interoperability.</para>
    /// <para>On OpenGL 2.1, mpv will strictly call functions like glGenTextures() to</para>
    /// <para>create OpenGL objects. You will have to do the same. This ensures that</para>
    /// <para>objects created by mpv and the API users don't clash. Also, legacy state</para>
    /// <para>must be either in its defaults, or not interfere with core state.</para>
    /// <para>Threading</para>
    /// <para>---------</para>
    /// <para>The mpv_opengl_cb_* functions can be called from any thread, under the</para>
    /// <para>following conditions:</para>
    /// <para>- only one of the mpv_opengl_cb_* functions can be called at the same time</para>
    /// <para>(unless they belong to different mpv cores created by mpv_create())</para>
    /// <para>- for functions which need an OpenGL context (see above) the OpenGL context</para>
    /// <para>must be &quot;current&quot; in the current thread, and it must be the same context</para>
    /// <para>as used with mpv_opengl_cb_init_gl()</para>
    /// <para>- never can be called from within the callbacks set with</para>
    /// <para>mpv_set_wakeup_callback() or mpv_opengl_cb_set_update_callback()</para>
    /// <para>Context and handle lifecycle</para>
    /// <para>----------------------------</para>
    /// <para>Video initialization will fail if the OpenGL context was not initialized yet</para>
    /// <para>(with mpv_opengl_cb_init_gl()). Likewise, mpv_opengl_cb_uninit_gl() will</para>
    /// <para>disable video.</para>
    /// <para>When the mpv core is destroyed (e.g. via mpv_terminate_destroy()), the OpenGL</para>
    /// <para>context must have been uninitialized. If this doesn't happen, undefined</para>
    /// <para>behavior will result.</para>
    /// <para>Hardware decoding</para>
    /// <para>-----------------</para>
    /// <para>Hardware decoding via opengl_cb is fully supported, but requires some</para>
    /// <para>additional setup. (At least if direct hardware decoding modes are wanted,</para>
    /// <para>instead of copying back surface data from GPU to CPU RAM.)</para>
    /// <para>While &quot;normal&quot; mpv loads the OpenGL hardware decoding interop on demand,</para>
    /// <para>this can't be done with opengl_cb for internal technical reasons. Instead,</para>
    /// <para>it loads them by default, even if hardware decoding is not going to be used.</para>
    /// <para>In older mpv relases, this had to be done by setting the</para>
    /// <para>&quot;opengl-hwdec-interop&quot; or &quot;hwdec-preload&quot; options before calling</para>
    /// <para>mpv_opengl_cb_init_gl(). You can still use the newer &quot;gpu-hwdec-interop&quot;</para>
    /// <para>option to prevent loading of interop, or to load only a specific interop.</para>
    /// <para>There may be certain requirements on the OpenGL implementation:</para>
    /// <para>- Windows: ANGLE is required (although in theory GL/DX interop could be used)</para>
    /// <para>- Intel/Linux: EGL is required, and also a glMPGetNativeDisplay() callback</para>
    /// <para>must be provided (see sections below)</para>
    /// <para>- nVidia/Linux: Both GLX and EGL should work (GLX is required if vdpau is</para>
    /// <para>used, e.g. due to old drivers.)</para>
    /// <para>- OSX: CGL is required (CGLGetCurrentContext() returning non-NULL)</para>
    /// <para>- iOS: EAGL is required (EAGLContext.currentContext returning non-nil)</para>
    /// <para>Once these things are setup, hardware decoding can be enabled/disabled at</para>
    /// <para>any time by setting the &quot;hwdec&quot; property.</para>
    /// <para>Special windowing system interop considerations</para>
    /// <para>------------------------------------------------</para>
    /// <para>In some cases, libmpv needs to have access to the windowing system's handles.</para>
    /// <para>This can be a pointer to a X11 &quot;Display&quot; for example. Usually this is needed</para>
    /// <para>only for hardware decoding.</para>
    /// <para>You can communicate these handles to libmpv by adding a pseudo-OpenGL</para>
    /// <para>extension &quot;GL_MP_MPGetNativeDisplay&quot; to the additional extension string when</para>
    /// <para>calling mpv_opengl_cb_init_gl(). The get_proc_address callback should resolve</para>
    /// <para>a function named &quot;glMPGetNativeDisplay&quot;, which has the signature:</para>
    /// <para>void* GLAPIENTRY glMPGetNativeDisplay(const char* name)</para>
    /// <para>See below what names are defined. Usually, libmpv will use the native handle</para>
    /// <para>up until mpv_opengl_cb_uninit_gl() is called. If the name is not anything</para>
    /// <para>you know/expected, return NULL from the function.</para>
    /// <para>* Windowing system scaling</para>
    /// <para>------------------------------------</para>
    /// <para>When using GL, sometimes GL rendering window is upscaled to display buffer.</para>
    /// <para>Typically with drm where GL framebuffer can be upscaled at later stage.</para>
    /// <para>In That case glMPGetNativeDisplay(&quot;opengl-cb-window-pos&quot;) should return an</para>
    /// <para>mpv_opengl_cb_window_pos struct pointer defined below.</para>
    /// <para>Note : The intended use is for hardware overlays that might require</para>
    /// <para>upscaling features (typically upscaling GL windows with drm to screen size).</para>
    /// <para>This is never used for GL rendering - only to map hardware overlays to</para>
    /// <para>GL rendering (for backends which support it).</para>
    /// </remarks>
    public unsafe partial class MpvOpenglCbWindowPos : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int x;

            [FieldOffset(4)]
            internal int y;

            [FieldOffset(8)]
            internal int width;

            [FieldOffset(12)]
            internal int height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24mpv_opengl_cb_window_posC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbWindowPos> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbWindowPos>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvOpenglCbWindowPos __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbWindowPos(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvOpenglCbWindowPos __CreateInstance(global::MPVLib.MpvOpenglCbWindowPos.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbWindowPos(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvOpenglCbWindowPos.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbWindowPos.__Internal));
            *(global::MPVLib.MpvOpenglCbWindowPos.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvOpenglCbWindowPos(global::MPVLib.MpvOpenglCbWindowPos.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvOpenglCbWindowPos(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvOpenglCbWindowPos()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbWindowPos.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvOpenglCbWindowPos(global::MPVLib.MpvOpenglCbWindowPos _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbWindowPos.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) __Instance) = *((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvOpenglCbWindowPos __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int X
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*)__Instance)->x = value;
            }
        }

        public int Y
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*)__Instance)->y = value;
            }
        }

        public int Width
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbWindowPos.__Internal*)__Instance)->height = value;
            }
        }
    }

    /// <summary>
    /// <para>Windowing system interop on Intel/Linux with VAAPI</para>
    /// <para>--------------------------------------------------</para>
    /// </summary>
    /// <remarks>
    /// <para>The new VAAPI OpenGL interop requires an EGL context. EGL provides no way</para>
    /// <para>to query the X11 Display associated to a specific EGL context, so this API</para>
    /// <para>is used to pass it through.</para>
    /// <para>glMPGetNativeDisplay(&quot;x11&quot;) should return a X11 &quot;Display*&quot;, which then will</para>
    /// <para>be used to create the hardware decoder state.</para>
    /// <para>glMPGetNativeDisplay(&quot;wl&quot;) should return a Wayland &quot;struct wl_display *&quot;.</para>
    /// <para>glMPGetNativeDisplay(&quot;opengl-cb-drm-params&quot;) should return an</para>
    /// <para>mpv_opengl_cb_drm_params structure pointer :</para>
    /// </remarks>
    public unsafe partial class MpvOpenglCbDrmParams : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int fd;

            [FieldOffset(4)]
            internal int crtc_id;

            [FieldOffset(8)]
            internal global::System.IntPtr atomic_request;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN24mpv_opengl_cb_drm_paramsC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbDrmParams> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbDrmParams>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvOpenglCbDrmParams __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbDrmParams(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvOpenglCbDrmParams __CreateInstance(global::MPVLib.MpvOpenglCbDrmParams.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbDrmParams(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvOpenglCbDrmParams.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbDrmParams.__Internal));
            *(global::MPVLib.MpvOpenglCbDrmParams.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvOpenglCbDrmParams(global::MPVLib.MpvOpenglCbDrmParams.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvOpenglCbDrmParams(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvOpenglCbDrmParams()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbDrmParams.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvOpenglCbDrmParams(global::MPVLib.MpvOpenglCbDrmParams _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbDrmParams.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance) = *((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvOpenglCbDrmParams __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Fd
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->fd;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbDrmParams.__Internal*)__Instance)->fd = value;
            }
        }

        public int CrtcId
        {
            get
            {
                return ((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->crtc_id;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbDrmParams.__Internal*)__Instance)->crtc_id = value;
            }
        }

        public global::MPVLib.DrmModeAtomicReq AtomicRequest
        {
            get
            {
                global::MPVLib.DrmModeAtomicReq __result0;
                if (((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->atomic_request == IntPtr.Zero) __result0 = null;
                else if (global::MPVLib.DrmModeAtomicReq.NativeToManagedMap.ContainsKey(((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->atomic_request))
                    __result0 = (global::MPVLib.DrmModeAtomicReq) global::MPVLib.DrmModeAtomicReq.NativeToManagedMap[((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->atomic_request];
                else __result0 = global::MPVLib.DrmModeAtomicReq.__CreateInstance(((global::MPVLib.MpvOpenglCbDrmParams.__Internal*) __Instance)->atomic_request);
                return __result0;
            }

            set
            {
                ((global::MPVLib.MpvOpenglCbDrmParams.__Internal*)__Instance)->atomic_request = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class DrmModeAtomicReq
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.DrmModeAtomicReq> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.DrmModeAtomicReq>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.DrmModeAtomicReq __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.DrmModeAtomicReq(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.DrmModeAtomicReq __CreateInstance(global::MPVLib.DrmModeAtomicReq.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.DrmModeAtomicReq(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.DrmModeAtomicReq.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.DrmModeAtomicReq.__Internal));
            *(global::MPVLib.DrmModeAtomicReq.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DrmModeAtomicReq(global::MPVLib.DrmModeAtomicReq.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DrmModeAtomicReq(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class MpvOpenglCbContext
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvOpenglCbContext>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvOpenglCbContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbContext(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvOpenglCbContext __CreateInstance(global::MPVLib.MpvOpenglCbContext.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvOpenglCbContext(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvOpenglCbContext.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvOpenglCbContext.__Internal));
            *(global::MPVLib.MpvOpenglCbContext.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvOpenglCbContext(global::MPVLib.MpvOpenglCbContext.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvOpenglCbContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class opengl_cb
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_set_update_callback")]
            internal static extern void MpvOpenglCbSetUpdateCallback(global::System.IntPtr ctx, global::System.IntPtr callback, global::System.IntPtr callback_ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_init_gl")]
            internal static extern int MpvOpenglCbInitGl(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string exts, global::System.IntPtr get_proc_address, global::System.IntPtr get_proc_address_ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_draw")]
            internal static extern int MpvOpenglCbDraw(global::System.IntPtr ctx, int fbo, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_render")]
            internal static extern int MpvOpenglCbRender(global::System.IntPtr ctx, int fbo, int[] vp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_report_flip")]
            internal static extern int MpvOpenglCbReportFlip(global::System.IntPtr ctx, long time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_opengl_cb_uninit_gl")]
            internal static extern int MpvOpenglCbUninitGl(global::System.IntPtr ctx);
        }

        /// <summary>
        /// <para>Set the callback that notifies you when a new video frame is available, or</para>
        /// <para>if the video display configuration somehow changed and requires a redraw.</para>
        /// <para>Similar to mpv_set_wakeup_callback(), you must not call any mpv API from</para>
        /// <para>the callback.</para>
        /// </summary>
        /// <param name="callback">
        /// <para>callback(callback_ctx) is called if the frame should be</para>
        /// <para>redrawn</para>
        /// </param>
        /// <param name="callback_ctx">opaque argument to the callback</param>
        public static void MpvOpenglCbSetUpdateCallback(global::MPVLib.MpvOpenglCbContext ctx, global::MPVLib.MpvOpenglCbUpdateFn callback, global::System.IntPtr callback_ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.MpvOpenglCbSetUpdateCallback(__arg0, __arg1, callback_ctx);
        }

        /// <summary>
        /// <para>Initialize the mpv OpenGL state. This retrieves OpenGL function pointers via</para>
        /// <para>get_proc_address, and creates OpenGL objects needed by mpv internally. It</para>
        /// <para>will also call APIs needed for rendering hardware decoded video in OpenGL,</para>
        /// <para>according to the mpv &quot;hwdec&quot; option.</para>
        /// </summary>
        /// <param name="exts">optional _additional_ extension string, can be NULL</param>
        /// <param name="get_proc_address">
        /// <para>callback used to retrieve function pointers to OpenGL</para>
        /// <para>functions. This is used for both standard functions</para>
        /// <para>and extension functions. (The extension string is</para>
        /// <para>checked whether extensions are really available.)</para>
        /// <para>The callback will be called from this function only</para>
        /// <para>(it is not stored and never used later).</para>
        /// <para>Usually, GL context APIs do this for you (e.g. with</para>
        /// <para>glXGetProcAddressARB or wglGetProcAddress), but</para>
        /// <para>some APIs do not always return pointers for all</para>
        /// <para>standard functions (even if present); in this case</para>
        /// <para>you have to compensate by looking up these functions</para>
        /// <para>yourself.</para>
        /// </param>
        /// <param name="get_proc_address_ctx">
        /// <para>arbitrary opaque user context passed to the</para>
        /// <para>get_proc_address callback</para>
        /// </param>
        /// <returns>
        /// <para>error code (same as normal mpv_* API), including but not limited to:</para>
        /// <para>MPV_ERROR_UNSUPPORTED: the OpenGL version is not supported</para>
        /// <para>(or required extensions are missing)</para>
        /// <para>MPV_ERROR_INVALID_PARAMETER: the OpenGL state was already initialized</para>
        /// </returns>
        /// <remarks>
        /// <para>You must free the associated state at some point by calling the</para>
        /// <para>mpv_opengl_cb_uninit_gl() function. Not doing so may result in memory leaks</para>
        /// <para>or worse.</para>
        /// </remarks>
        public static int MpvOpenglCbInitGl(global::MPVLib.MpvOpenglCbContext ctx, string exts, global::MPVLib.MpvOpenglCbGetProcAddressFn get_proc_address, global::System.IntPtr get_proc_address_ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg2 = get_proc_address == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(get_proc_address);
            var __ret = __Internal.MpvOpenglCbInitGl(__arg0, exts, __arg2, get_proc_address_ctx);
            return __ret;
        }

        /// <summary>Render video. Requires that the OpenGL state is initialized.</summary>
        /// <param name="fbo">
        /// <para>The framebuffer object to render on. Because the renderer might</para>
        /// <para>manage multiple FBOs internally for the purpose of video</para>
        /// <para>postprocessing, it will always bind and unbind FBOs itself. If</para>
        /// <para>you want mpv to render on the main framebuffer, pass 0.</para>
        /// </param>
        /// <param name="w">
        /// <para>Width of the framebuffer. This is either the video size if the fbo</para>
        /// <para>parameter is 0, or the allocated size of the texture backing the</para>
        /// <para>fbo. The renderer will always use the full size of the fbo.</para>
        /// </param>
        /// <param name="h">
        /// <para>Height of the framebuffer. Same as with the w parameter, except</para>
        /// <para>that this parameter can be negative. In this case, the video</para>
        /// <para>frame will be rendered flipped.</para>
        /// </param>
        /// <returns>0</returns>
        /// <remarks>
        /// <para>The video will use the full provided framebuffer. Options like &quot;panscan&quot; are</para>
        /// <para>applied to determine which part of the video should be visible and how the</para>
        /// <para>video should be scaled. You can change these options at runtime by using the</para>
        /// <para>mpv property API.</para>
        /// <para>The renderer will reconfigure itself every time the output rectangle/size</para>
        /// <para>is changed. (If you want to do animations, it might be better to do the</para>
        /// <para>animation on a FBO instead.)</para>
        /// <para>This function implicitly pulls a video frame from the internal queue and</para>
        /// <para>renders it. If no new frame is available, the previous frame is redrawn.</para>
        /// <para>The update callback set with mpv_opengl_cb_set_update_callback() notifies</para>
        /// <para>you when a new frame was added.</para>
        /// </remarks>
        public static int MpvOpenglCbDraw(global::MPVLib.MpvOpenglCbContext ctx, int fbo, int w, int h)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvOpenglCbDraw(__arg0, fbo, w, h);
            return __ret;
        }

        /// <summary>Deprecated. Use mpv_opengl_cb_draw(). This function is equivalent to:</summary>
        /// <remarks>
        /// <para>int mpv_opengl_cb_render(mpv_opengl_cb_context *ctx, int fbo, int vp[4])</para>
        /// <para>{ return mpv_opengl_cb_draw(ctx, fbo, vp[2], vp[3]); }</para>
        /// <para>vp[0] and vp[1] used to have a meaning, but are ignored in newer versions.</para>
        /// <para>This function will be removed in the future without version bump (this API</para>
        /// <para>was never marked as stable).</para>
        /// </remarks>
        public static int MpvOpenglCbRender(global::MPVLib.MpvOpenglCbContext ctx, int fbo, int[] vp)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            if (vp == null || vp.Length != 4)
                throw new ArgumentOutOfRangeException("vp", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.MpvOpenglCbRender(__arg0, fbo, vp);
            return __ret;
        }

        /// <summary>
        /// <para>Tell the renderer that a frame was flipped at the given time. This is</para>
        /// <para>optional, but can help the player to achieve better timing.</para>
        /// </summary>
        /// <param name="time">
        /// <para>The mpv time (using mpv_get_time_us()) at which the flip call</para>
        /// <para>returned. If 0 is passed, mpv_get_time_us() is used instead.</para>
        /// <para>Currently, this parameter is ignored.</para>
        /// </param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>Note that calling this at least once informs libmpv that you will use this</para>
        /// <para>function. If you use it inconsistently, expect bad video playback.</para>
        /// <para>If this is called while no video or no OpenGL is initialized, it is ignored.</para>
        /// </remarks>
        public static int MpvOpenglCbReportFlip(global::MPVLib.MpvOpenglCbContext ctx, long time)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvOpenglCbReportFlip(__arg0, time);
            return __ret;
        }

        /// <summary>Destroy the mpv OpenGL state.</summary>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>If video is still active (e.g. a file playing), video will be disabled</para>
        /// <para>forcefully.</para>
        /// <para>Calling this multiple times is ok.</para>
        /// </remarks>
        public static int MpvOpenglCbUninitGl(global::MPVLib.MpvOpenglCbContext ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.MpvOpenglCbUninitGl(__arg0);
            return __ret;
        }
    }

    /// <summary>
    /// <para>Read callback used to implement a custom stream. The semantics of the</para>
    /// <para>callback match read(2) in blocking mode. Short reads are allowed (you can</para>
    /// <para>return less bytes than requested, and libmpv will retry reading the rest</para>
    /// <para>with a nother call). If no data can be immediately read, the callback must</para>
    /// <para>block until there is new data. A return of 0 will be interpreted as final</para>
    /// <para>EOF, although libmpv might retry the read, or seek to a different position.</para>
    /// </summary>
    /// <param name="cookie">
    /// <para>opaque cookie identifying the stream,</para>
    /// <para>returned from mpv_stream_cb_open_fn</para>
    /// </param>
    /// <param name="buf">buffer to read data into</param>
    /// <param name="size">of the buffer</param>
    /// <returns>number of bytes read into the buffer</returns>
    /// <returns>0 on EOF</returns>
    /// <returns>-1 on error</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate long MpvStreamCbReadFn(global::System.IntPtr cookie, sbyte* buf, ulong nbytes);

    /// <summary>Seek callback used to implement a custom stream.</summary>
    /// <param name="cookie">
    /// <para>opaque cookie identifying the stream,</para>
    /// <para>returned from mpv_stream_cb_open_fn</para>
    /// </param>
    /// <param name="offset">target absolut stream position</param>
    /// <returns>
    /// <para>the resulting offset of the stream</para>
    /// <para>MPV_ERROR_UNSUPPORTED or MPV_ERROR_GENERIC if the seek failed</para>
    /// </returns>
    /// <remarks>
    /// <para>Note that mpv will issue a seek to position 0 immediately after opening. This</para>
    /// <para>is used to test whether the stream is seekable (since seekability might</para>
    /// <para>depend on the URI contents, not just the protocol). Return</para>
    /// <para>MPV_ERROR_UNSUPPORTED if seeking is not implemented for this stream. This</para>
    /// <para>seek also servies to establish the fact that streams start at position 0.</para>
    /// <para>This callback can be NULL, in which it behaves as if always returning</para>
    /// <para>MPV_ERROR_UNSUPPORTED.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate long MpvStreamCbSeekFn(global::System.IntPtr cookie, long offset);

    /// <summary>Size callback used to implement a custom stream.</summary>
    /// <param name="cookie">
    /// <para>opaque cookie identifying the stream,</para>
    /// <para>returned from mpv_stream_cb_open_fn</para>
    /// </param>
    /// <returns>the total size in bytes of the stream</returns>
    /// <remarks>
    /// <para>Return MPV_ERROR_UNSUPPORTED if no size is known.</para>
    /// <para>This callback can be NULL, in which it behaves as if always returning</para>
    /// <para>MPV_ERROR_UNSUPPORTED.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate long MpvStreamCbSizeFn(global::System.IntPtr cookie);

    /// <summary>Close callback used to implement a custom stream.</summary>
    /// <param name="cookie">
    /// <para>opaque cookie identifying the stream,</para>
    /// <para>returned from mpv_stream_cb_open_fn</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void MpvStreamCbCloseFn(global::System.IntPtr cookie);

    /// <summary>
    /// <para>Open callback used to implement a custom read-only (ro) stream. The user</para>
    /// <para>must set the callback fields in the passed info struct. The cookie field</para>
    /// <para>also can be set to store state associated to the stream instance.</para>
    /// </summary>
    /// <param name="user_data">opaque user data provided via mpv_stream_cb_add()</param>
    /// <param name="uri">name of the stream to be opened (with protocol prefix)</param>
    /// <param name="info">fields which the user should fill</param>
    /// <returns>0 on success, MPV_ERROR_LOADING_FAILED if the URI cannot be opened.</returns>
    /// <remarks>
    /// <para>Note that the info struct is valid only for the duration of this callback.</para>
    /// <para>You can't change the callbacks or the pointer to the cookie at a later point.</para>
    /// <para>Each stream instance created by the open callback can have different</para>
    /// <para>callbacks.</para>
    /// <para>The close_fn callback will terminate the stream instance. The pointers to</para>
    /// <para>your callbacks and cookie will be discarded, and the callbacks will not be</para>
    /// <para>called again.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int MpvStreamCbOpenRoFn(global::System.IntPtr user_data, sbyte* uri, global::System.IntPtr info);

    /// <summary>See mpv_stream_cb_open_ro_fn callback.</summary>
    public unsafe partial class MpvStreamCbInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr cookie;

            [FieldOffset(8)]
            internal global::System.IntPtr read_fn;

            [FieldOffset(16)]
            internal global::System.IntPtr seek_fn;

            [FieldOffset(24)]
            internal global::System.IntPtr size_fn;

            [FieldOffset(32)]
            internal global::System.IntPtr close_fn;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN18mpv_stream_cb_infoC2ERKS_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvStreamCbInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::MPVLib.MpvStreamCbInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::MPVLib.MpvStreamCbInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvStreamCbInfo(native.ToPointer(), skipVTables);
        }

        internal static global::MPVLib.MpvStreamCbInfo __CreateInstance(global::MPVLib.MpvStreamCbInfo.__Internal native, bool skipVTables = false)
        {
            return new global::MPVLib.MpvStreamCbInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::MPVLib.MpvStreamCbInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvStreamCbInfo.__Internal));
            *(global::MPVLib.MpvStreamCbInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MpvStreamCbInfo(global::MPVLib.MpvStreamCbInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MpvStreamCbInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MpvStreamCbInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvStreamCbInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MpvStreamCbInfo(global::MPVLib.MpvStreamCbInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::MPVLib.MpvStreamCbInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance) = *((global::MPVLib.MpvStreamCbInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::MPVLib.MpvStreamCbInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Cookie
        {
            get
            {
                return ((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance)->cookie;
            }

            set
            {
                ((global::MPVLib.MpvStreamCbInfo.__Internal*)__Instance)->cookie = (global::System.IntPtr) value;
            }
        }

        public global::MPVLib.MpvStreamCbReadFn ReadFn
        {
            get
            {
                var __ptr0 = ((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance)->read_fn;
                return __ptr0 == IntPtr.Zero? null : (global::MPVLib.MpvStreamCbReadFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::MPVLib.MpvStreamCbReadFn));
            }

            set
            {
                ((global::MPVLib.MpvStreamCbInfo.__Internal*)__Instance)->read_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::MPVLib.MpvStreamCbSeekFn SeekFn
        {
            get
            {
                var __ptr0 = ((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance)->seek_fn;
                return __ptr0 == IntPtr.Zero? null : (global::MPVLib.MpvStreamCbSeekFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::MPVLib.MpvStreamCbSeekFn));
            }

            set
            {
                ((global::MPVLib.MpvStreamCbInfo.__Internal*)__Instance)->seek_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::MPVLib.MpvStreamCbSizeFn SizeFn
        {
            get
            {
                var __ptr0 = ((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance)->size_fn;
                return __ptr0 == IntPtr.Zero? null : (global::MPVLib.MpvStreamCbSizeFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::MPVLib.MpvStreamCbSizeFn));
            }

            set
            {
                ((global::MPVLib.MpvStreamCbInfo.__Internal*)__Instance)->size_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::MPVLib.MpvStreamCbCloseFn CloseFn
        {
            get
            {
                var __ptr0 = ((global::MPVLib.MpvStreamCbInfo.__Internal*) __Instance)->close_fn;
                return __ptr0 == IntPtr.Zero? null : (global::MPVLib.MpvStreamCbCloseFn) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::MPVLib.MpvStreamCbCloseFn));
            }

            set
            {
                ((global::MPVLib.MpvStreamCbInfo.__Internal*)__Instance)->close_fn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class stream_cb
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("mpv-1.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="mpv_stream_cb_add_ro")]
            internal static extern int MpvStreamCbAddRo(global::System.IntPtr ctx, [MarshalAs(UnmanagedType.LPStr)] string protocol, global::System.IntPtr user_data, global::System.IntPtr open_fn);
        }

        /// <summary>
        /// <para>Add a custom stream protocol. This will register a protocol handler under</para>
        /// <para>the given protocol prefix, and invoke the given callbacks if an URI with the</para>
        /// <para>matching protocol prefix is opened.</para>
        /// </summary>
        /// <param name="protocol">protocol prefix, for example &quot;foo&quot; for &quot;foo://&quot; URIs</param>
        /// <param name="user_data">
        /// <para>opaque pointer passed into the mpv_stream_cb_open_fn</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>error code</returns>
        /// <remarks>
        /// <para>The &quot;ro&quot; is for read-only - only read-only streams can be registered with</para>
        /// <para>this function.</para>
        /// <para>The callback remains registered until the mpv core is registered.</para>
        /// <para>If a custom stream with the same name is already registered, then the</para>
        /// <para>MPV_ERROR_INVALID_PARAMETER error is returned.</para>
        /// </remarks>
        public static int MpvStreamCbAddRo(global::MPVLib.MpvHandle ctx, string protocol, global::System.IntPtr user_data, global::MPVLib.MpvStreamCbOpenRoFn open_fn)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            var __arg3 = open_fn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(open_fn);
            var __ret = __Internal.MpvStreamCbAddRo(__arg0, protocol, user_data, __arg3);
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr _0);
    }
}
